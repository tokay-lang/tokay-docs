<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tokay programming language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/items.html"><strong aria-hidden="true">3.1.</strong> Items</a></li><li class="chapter-item expanded "><a href="basics/sequences.html"><strong aria-hidden="true">3.2.</strong> Sequences</a></li><li class="chapter-item expanded "><a href="basics/blocks.html"><strong aria-hidden="true">3.3.</strong> Blocks</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/terminology.html"><strong aria-hidden="true">4.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="concepts/values.html"><strong aria-hidden="true">4.2.</strong> Values</a></li><li class="chapter-item expanded "><a href="concepts/objects.html"><strong aria-hidden="true">4.3.</strong> Objects</a></li><li class="chapter-item expanded "><a href="concepts/tokens.html"><strong aria-hidden="true">4.4.</strong> Tokens</a></li><li class="chapter-item expanded "><a href="concepts/parselets.html"><strong aria-hidden="true">4.5.</strong> Parselets</a></li></ol></li><li class="chapter-item expanded "><a href="control-structures.html"><strong aria-hidden="true">5.</strong> Control structures</a></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/keywords.html"><strong aria-hidden="true">6.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix/operators.html"><strong aria-hidden="true">6.2.</strong> B - Operators</a></li><li class="chapter-item expanded "><a href="appendix/modifiers.html"><strong aria-hidden="true">6.3.</strong> C - Modifiers</a></li><li class="chapter-item expanded "><a href="appendix/builtins.html"><strong aria-hidden="true">6.4.</strong> D - Builtins</a></li><li class="chapter-item expanded "><a href="appendix/escape-sequences.html"><strong aria-hidden="true">6.5.</strong> E - Escape sequences</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tokay programming language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<blockquote>
<p>The Tokay documentation is currently under heavy development and unfinished.
Feel free to contribute! To do so, visit <a href="https://github.com/tokay-lang">https://github.com/tokay-lang</a>.</p>
</blockquote>
<p>Tokay is a programming language designed for ad-hoc parsing and text processing. Tokay programs operate directly on input streams that are read from files, strings, piped commands or any other device emitting characters.</p>
<p>The following example is a short Tokay program that illustrates how Tokay works. It recognizes either &quot;Hello Mercury&quot;, &quot;Hello Venus&quot; or &quot;Hello Earth&quot; from a text stream. Any other input is automatically skipped.</p>
<pre><code class="language-tokay">'Hello' _ {
    'Mercury'
    'Venus'
    'Earth'
}
</code></pre>
<p>Unlike general purpose programming languages like Rust or Python, in Tokay no explicit branching, substring extraction, or reading from input is required. Instead, these operations are directly built into the language.</p>
<p>If you're familiar with <a href="https://en.wikipedia.org/wiki/AWK">awk</a>, you might find the syntax in the previous example to be similar to awk's <code>PATTERN { action }</code> syntax. This approach is recursive in Tokay, so that the action-part can also be treated as a pattern, or as plain action code. This highlights a core tenet of Tokay's design and its key difference from awk: instead of using a line-based execution model, Tokay takes a token-based approach that permits operating on anything matched from the input. This enables Tokay programs to operate on recursive structures that can be expressed by a grammar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Currently, Tokay is in a very early project state. Therefore you have to built it from source, using the <a href="https://www.rust-lang.org/">Rust</a> programming language and its build-tool <code>cargo</code>.</p>
<p>Once you got Rust installed, install <a href="https://crates.io/crates/tokay">Tokay</a> with <code>cargo install tokay</code>.</p>
<p>When this is done, you can run Tokay directly, like so, to start a REPL:</p>
<pre><code class="language-bash">$ tokay
Tokay 0.4.0
&gt;&gt;&gt; print(&quot;Hello Tokay&quot;)
Hello Tokay
&gt;&gt;&gt;
</code></pre>
<p>To exit the REPL, type <code>exit</code> or press <code>Ctrl+C</code>.</p>
<h2 id="using-the-tokay-command"><a class="header" href="#using-the-tokay-command">Using the <code>tokay</code> command</a></h2>
<p>Invoking the <code>tokay</code> command without any arguments starts the REPL (read-eval-print-loop). This allows to enter expressions or even full programs interactively with a direct result.</p>
<p>Start a REPL</p>
<pre><code class="language-bash">$ tokay
Tokay 0.4.0
&gt;&gt;&gt; 23 * 5
115
&gt;&gt;&gt; for i=0; i &lt; 10; i++ print(i)
0
1
2
3
4
5
6
7
8
9
&gt;&gt;&gt;
</code></pre>
<p>Start a REPL working on an input stream read from <code>file.txt</code>:</p>
<pre><code class="language-bash">$ tokay -- file.txt
</code></pre>
<p>Start a REPL working on the input string &quot;save all the whales&quot;:</p>
<pre><code class="language-bash">$ tokay -- &quot;save all the whales&quot;
Tokay 0.4.0
&gt;&gt;&gt; Word
(&quot;save&quot;, &quot;all&quot;, &quot;the&quot;, &quot;whales&quot;)
&gt;&gt;&gt;
</code></pre>
<blockquote>
<p>In case you compile and run Tokay from the source code of the Git repository on your own, just run <code>cargo run --</code> with any desired parameters attached.</p>
</blockquote>
<p>Next runs the Tokay program from the file <em>prog.tok</em>:</p>
<pre><code class="language-bash">$ tokay prog.tok
...
</code></pre>
<p>To directly work on files as input stream, do this as shown next. Further files can be specified and are executed on the same program sequentially. Its also possible to read from stdin using the special filename <code>-</code>.</p>
<p>Run a program from a file with another file as input stream</p>
<pre><code class="language-bash">$ tokay prog.tok -- file.txt
...
</code></pre>
<p>Run a program from with multiple files as input stream</p>
<pre><code class="language-bash">$ tokay prog.tok -- file1.txt file2.txt file3.txt
...
</code></pre>
<p>Run a program from with files or strings as input stream</p>
<pre><code class="language-bash">$ tokay prog.tok -- file1.txt &quot;save all the whales&quot; file2.txt
...
</code></pre>
<p>Pipe input through tokay</p>
<pre><code class="language-bash">$ cat file.txt | tokay prog.tok -- -
...
</code></pre>
<p>A Tokay program can also be specified directly by parameter. This call just prints the content of the files specified:</p>
<pre><code class="language-shell">$ tokay '.+' -- file1.txt file2.txt file3.txt
file1.txt: ...
file2.txt: ...
file3.txt: ...
</code></pre>
<h2 id="first-steps"><a class="header" href="#first-steps">First steps</a></h2>
<p>Next you can see some little programs expressed in Tokay to become familiar with the syntax and behavior.</p>
<h3 id="hello-tokay"><a class="header" href="#hello-tokay">Hello Tokay</a></h3>
<p>You probably found out how to express the &quot;Hello World&quot; program in Tokay already.</p>
<pre><code class="language-tokay">print(&quot;Hello World&quot;)
</code></pre>
<h3 id="tokens"><a class="header" href="#tokens">Tokens</a></h3>
<h3 id="writing-comments"><a class="header" href="#writing-comments">Writing comments</a></h3>
<p>It is good practise to document source code and what's going on using comments. Likewise bash, Python or awk, Tokay supports line-comments starting with a hash (<code>#</code>). The rest of the line will be ignored.</p>
<pre><code class="language-tokay"># This is my little program

print(&quot;Hello World&quot;)  # printing welcome message to the user
hash = &quot;# this is a string&quot;  # assign &quot;# this is a string&quot; to hash.
</code></pre>
<h3 id="shebang"><a class="header" href="#shebang">Shebang</a></h3>
<p>Therefore a shebang is also possible in case a Tokay source file shall be directly executable.</p>
<pre><code class="language-tokay">#!/bin/tokay
print(&quot;Hello World&quot;)
</code></pre>
<p>This assumes <code>tokay</code> is installed to <code>/bin</code> on a Posix-like system.</p>
<pre><code class="language-bash">$ ls -lta hello.tok
-rwxr-xr-x  hello.tok
$ ./hello.tok
Hello World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Basically, a Tokay program is established on these parts:</p>
<ul>
<li>Items</li>
<li>Sequences</li>
<li>Blocks</li>
</ul>
<p>All these parts belong together and depend on each other in some way.</p>
<p>The following Tokay program demonstrates the usage of all three of these parts in action.</p>
<pre><code class="language-tokay">{ # A block...
    # ... is made of sequences
    'Hello' _ Name count_hello++   # ... which are made of items.

    'Goodbye' _ {  # an item of a sequence can be a block again
        'Max'  count_bye_max++  # ... which contains one sequences with items
        Name   count_bye++      # ... and a second one, too.
    }

    {}  # a sequence with an empty block as its item
}
</code></pre>
<p>This program is a little parser, which looks for greetings in some input.</p>
<ul>
<li>The occurence of e.g. <code>Hello Jan</code> and <code>Hello Max</code> causes the variable<code>count_hello</code> to be incremented</li>
<li>The occurence of e.g. <code>Goodbye Jan</code> increments the counter <code>count_bye</code>, but</li>
<li>An occurence of <code>Goodbye Max</code>, which is a special case here, counts on <code>count_bye_max</code>.</li>
</ul>
<blockquote>
<p>If you are familiar with the <em>Awk programming language</em>, you might see some similarities to the <code>PATTERN { action }</code>-syntax here.</p>
<p>In Tokay, <em>PATTERN</em> can be any sequence of items that need to match before, and <em>{ action }</em> can hold further <code>PATTERN { action }</code>-components.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="items"><a class="header" href="#items">Items</a></h1>
<p>Items are the atomic parts of sequences, and represent values.</p>
<p>The following examples for items are direct values that, once specified, stay on their own.</p>
<pre><code class="language-tokay">123               # the number 123
true              # the boolean value for truth
&quot;Tokay 🦎&quot;        # a unicode string
</code></pre>
<p>Items can also be the result of expressions or calls to callable objects.</p>
<pre><code class="language-tokay">&quot;a &quot; + &quot;string&quot;   # concatenating a string
42 * 23.5         # the result of a multiplication
'check'           # the occurence of string &quot;check&quot; in the input
Integer           # calling a built-in token for parsing integer values
func(42)          # calling a function
++count           # the incremented value of count
</code></pre>
<p>But items can also be more complex.</p>
<pre><code class="language-tokay">x = count * 23.5  # the result of a calculation is assigned to a variable
</code></pre>
<p>This is an assignment, and always produces the item value <code>void</code>, which means just &quot;nothing&quot;. This is, because the result of the calculation is stored to a variable, but the item must represent some value.</p>
<p>Here's another item:</p>
<pre><code class="language-tokay">if x &gt; 100 &quot;much&quot; # conditional expression, which is either &quot;much&quot; or void
</code></pre>
<p>This <code>if</code>-clause allows for conditional programming. It either produces a string when the provided condition is met, and otherwise also produces <code>void</code>.</p>
<p>This behavior can be changed by providing an <code>else</code>-branch next, like this:</p>
<pre><code class="language-tokay">if x &gt; 100 &quot;much&quot; else &quot;less&quot;
</code></pre>
<p>As you see, every single value, call, expression or control-flow statement is considered to be an item.</p>
<p>A <a href="basics/blocks.html">block</a> is also an item as well, but this will be disussed later.</p>
<h2 id="severities"><a class="header" href="#severities">Severities</a></h2>
<blockquote>
<p>This is not important for the first steps and programs with Tokay, but a fundamental feature of the magic behind Tokay's automatic value construction features, which will be discussed later. You should know about it!</p>
</blockquote>
<p>Every item has a severity, which defines its value's &quot;weight&quot;.</p>
<p>Tokay currently knows 4 levels of severitity:</p>
<ol>
<li>Whitespace</li>
<li>Match</li>
<li>Value</li>
<li>Result</li>
</ol>
<p>The severity of an item depends on how it is constructed. For example</p>
<pre><code class="language-tokay">123               # pushes 123 with severity 3
_                 # matches whitespace
'check'           # matches &quot;check&quot; in input and pushes it considered as match
''check''         # matches &quot;check&quot; in input and pushes it considered as value
'check' * 3       # matches &quot;check&quot; in input and repeats it 3 times, resuling in value
push &quot;yes&quot;        # pushes result value &quot;yes&quot;
</code></pre>
<p>Right now, this isn't so important, and you shouldn't keep this in mind all the time. It will become useful during the next chapters, and especially when writing programs that parse or extract data off something.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In conclusion, an item is the result of some expression which always stands for a value. An item in turn is part of a sequence. Every item has a hidden severity, which is important for constructing values from sequences later on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequences"><a class="header" href="#sequences">Sequences</a></h1>
<p>Sequences are occurences of items in a row.</p>
<p>Here is a sequence of three items:</p>
<pre><code class="language-tokay">1 2 3 + 4    # results in a list (1, 2, 7)
</code></pre>
<p>For better readability, items of a sequence can be optionally separated by commas (<code>,</code>), so</p>
<pre><code class="language-tokay">1, 2, 3 + 4  # (1, 2, 7)
</code></pre>
<p>encodes the same.</p>
<p>All items of a sequence with a given severity are used to determine the result of the sequence. Therefore, these sequences return <code>(1, 2, 7)</code> in the above examples when entered in a Tokay REPL. This has to deal with the <a href="basics/items.html#severities">severities</a> the items own.</p>
<p>The end of the sequence is delimited by a line-break, but the sequence can be wrapped into to multiple using a backslash before the line-break. So</p>
<pre><code class="language-tokay">1, 2 \
3 + 4  # (1, 2, 7)
</code></pre>
<p>means also the same as above.</p>
<h2 id="captures"><a class="header" href="#captures">Captures</a></h2>
<p>The already executed items of a sequence are captured, so they can be accessed inside of the sequence using <em>capture variables</em>.</p>
<p>In the next example, the first capture, which holds the result <code>7</code> from the expression <code>3 + 4</code> is referenced with <code>$1</code> and used in the second item as value of the expression. Referencing a capture which is out of bounds will just return <code>void</code>.</p>
<pre><code class="language-tokay">3 + 4, $1 * 2  # (7, 14)
</code></pre>
<p>Captures can also be re-assigned by subsequent items. The next one assigns a value at the second item to the first item, and uses the first item inside of the calculation. The second item which is the assignment, exists also as item of the sequence and refers to <code>void</code>, as all assignments do.</p>
<blockquote>
<p>This is the reason why Tokay has two values to simply define nothing, which are <code>void</code> and <code>null</code>, but <code>null</code> has a higher precedence.</p>
</blockquote>
<pre><code class="language-tokay">3 + 4, $1 = $1 * 2  # 14
</code></pre>
<p>As the result of the above sequence, just one value results which is <code>14</code>, but the second item's value, <code>void</code>, has a lower severity than the calculated and assigned first value. This is the magic with sequences that you will soon figure out in detail, especially when tokens from streams are accessed and processed, or your programs work on extracted information from the input, and the automatic abstract syntax tree construction occurs.</p>
<p>As the last example, we shortly show how sequence items can also be named and accessed by a more meaningful name than just the index.</p>
<pre><code class="language-tokay">hello =&gt; &quot;Hello&quot;, $hello = 3 * $hello  # (hello =&gt; &quot;HelloHelloHello&quot;)
</code></pre>
<p>Here, the first item, which is referenced by the capture variable <code>$hello</code> is repeated 3 times as the second item.</p>
<p>It might be quite annoying, but the result of this sequence is a <em>dict</em> as shown in the comment. A dict is a hash-table where values can be referenced by a key.</p>
<blockquote>
<p>If you come from Python, you might already know about <em>list</em> and <em>dict</em> objects. Their behavior and meaning is similar in Tokay.</p>
</blockquote>
<h2 id="parsing-input-sequences"><a class="header" href="#parsing-input-sequences">Parsing input sequences</a></h2>
<p>As Tokay is a programming language with built-in parsing capabilities, let's see how parsing integrates to sequences and captures.</p>
<p>Given the sequence</p>
<pre><code class="language-tokay">Word __ ''the'' __ Word
</code></pre>
<p>we make use of the built-in token <code>Word</code> which matches anything made of characters and digits, and the special constant <code>__</code>, which matches arbitrary whitespace, but at least one whitespace character must be present. Whitespace is anything represented by non-printable characters, like spaces or tabs.</p>
<p>We can now run this sequence on any input existing of three words, where the word in the middle is &quot;the&quot;. Let's say</p>
<pre><code>Save the planet
</code></pre>
<p>and we get the output</p>
<pre><code>(&quot;Save&quot;, &quot;the&quot;, &quot;planet&quot;)
</code></pre>
<blockquote>
<p>To try it out, either start a Tokay REPL with <code>$ tokay -- &quot;Save the planet&quot;</code> and enter the sequence <code>Word __ ''the'' __ Word</code> afterwards, or directly specify both at invocation, like<br>
<code>$ tokay &quot;Word __ ''the'' __ Word&quot; -- &quot;Save the planet&quot;</code>.</p>
</blockquote>
<p>You will see, it's regardless of how many whitespace you insert, the result will always be the same. The reason for this are the item <a href="basics/items.html#severities">severities</a> discussed earlier. Whitespace, used by the pre-defined constant <code>__</code>, has a lower severity, and therefore won't make it in the result of the sequence.</p>
<h3 id="using-capture-aliases"><a class="header" href="#using-capture-aliases">Using capture aliases</a></h3>
<p>Captures can also have a name, called &quot;alias&quot;. This is ideal for parsing, to give items meaningful names and make them independent from their position.</p>
<pre><code class="language-tokay">predicate =&gt; Word __ 'the' __ object =&gt; Word
</code></pre>
<p>will output</p>
<pre><code>(object =&gt; &quot;planet&quot;, predicate =&gt; &quot;Save&quot;)
</code></pre>
<blockquote>
<p>In this example, the match for the word <code>''the''</code> was degrated to a touch <code>'the'</code>, which has a lower item severity and won't make it into the sequence result.</p>
<p>This was done to make the output more clear, and because &quot;the&quot; is only an article without relevance to the meaning of the sentence we try to parse.</p>
</blockquote>
<p>Now we can also work with alias variables inside of the sequence</p>
<pre><code class="language-tokay">predicate =&gt; Word __ 'the' __ object =&gt; Word \
    print(&quot;What to &quot; + $predicate.lower() + &quot;? The &quot; + $object + &quot;!&quot;)
</code></pre>
<p>will output</p>
<pre><code>What to save? The planet!
</code></pre>
<p>The advantage here is, that we can change the sequence to further items in between, and don't have to change all references to these items in the print function call, because they are identified by name, and not by their offset, which might have changed.</p>
<h3 id="the-capture-variable-0"><a class="header" href="#the-capture-variable-0">The capture variable $0</a></h3>
<p>There is also a special capture variable <code>$0</code>. It contains the input captured by the currently executed parselet the sequence belongs to. A parselet is a function that consumes some sort of input, which will be discussed later.</p>
<p>Let's see how all capture variables, including <code>$0</code>, are growing when the items from the examples above are being executed.</p>
<table>
    <tr>
        <td>
            <strong>Capture</strong>
        </td>
        <td>
            $1
        </td>
        <td>
            $2
        </td>
        <td>
            $3
        </td>
        <td>
            $4
        </td>
        <td>
            $5
        </td>
    </tr>
    <tr>
        <td>
            <strong>Alias</strong>
        </td>
        <td>
            $predicate
        </td>
        <td></td>
        <td></td>
        <td></td>
        <td>
            $object
        </td>
    </tr>
    <tr>
        <td>
            <strong>Item</strong>
        </td>
        <td>
            <code>predicate => Word</code>
        </td>
        <td>
            <code>__</code>
        </td>
        <td>
            <code>'the'</code>
        </td>
        <td>
            <code>__</code>
        </td>
        <td>
            <code>object => Word</code>
        </td>
    </tr>
    <tr>
        <td>
            <strong>Input</strong>
        </td>
        <td>
            "Save"
        </td>
        <td>
            " "
        </td>
        <td>
            "the"
        </td>
        <td>
            " "
        </td>
        <td>
            "planet"
        </td>
    </tr>
    <tr>
        <td>
            <strong>$0 contains</strong>
        </td>
        <td>
            "Save"
        </td>
        <td>
            "Save "
        </td>
        <td>
            "Save the"
        </td>
        <td>
            "Save the "
        </td>
        <td>
            "Save the planet"
        </td>
    </tr>
</table>
<p>As you can see, <code>$0</code> always contains the input matched so far from the start of the parselet.</p>
<p><code>$0</code> can also be assigned to any other value, which makes it the result of the parselet in case no other result of higher precedence was set.</p>
<h2 id="sequence-interruption"><a class="header" href="#sequence-interruption">Sequence interruption</a></h2>
<p>todo</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Sequences define occurences of items. An item inside of a sequence can have a meanigful alias.</p>
<p>Every item of a sequence that has been executed is called <em>a capture</em>, and can be accessed using context-variables, either by their offset (position of occurence) like <code>$1</code>, <code>$2</code>, <code>$3</code> or by their alias, like <code>$predicate</code>.</p>
<p>The special capture <code>$0</code> provides the consumed information read so far by the parselet, and can also be set to a value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks"><a class="header" href="#blocks">Blocks</a></h1>
<p>Sequences are organized in blocks. Blocks may contain several sequences, which are executed in order of their definition. Every sequence inside of a block is separated by a newline.</p>
<p>The main scope of a Tokay program is also an implicit block, therefore it is not necessary to start every program with a new block.</p>
<h2 id="newlines"><a class="header" href="#newlines">Newlines</a></h2>
<p>In Tokay, newlines (line-breaks, <code>\n</code> respectively) are meaningful. They separate sequences from each other, as you will learn in the next section.</p>
<pre><code class="language-tokay">&quot;1st&quot; &quot;sequence&quot;
&quot;2nd&quot; &quot;sequence&quot;
&quot;3rd&quot; &quot;sequence&quot;
</code></pre>
<p>Instead of a newline, a semicolon (<code>;</code>) can also be used, which has the same meaning. A single-line sequence can be split into multiple lines by preceding a backslash (<code>\</code>) in front of the line-break.</p>
<pre><code class="language-tokay">&quot;1st&quot; \
    &quot;sequence&quot;
&quot;2nd&quot; &quot;sequence&quot; ; &quot;3rd&quot; &quot;sequence&quot;
</code></pre>
<p>The first and second example are literally the same.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<h2 id="identifiers"><a class="header" href="#identifiers">Identifiers</a></h2>
<p>Naming rules for identifiers in Tokay differ to other programming languages, and this is an essential feature.</p>
<ol>
<li>As known from other languages, identifiers may not start with any digit (<code>0-9</code>).</li>
<li>Variables need to start with a lower-case letter from (<code>a-z</code>)</li>
<li>Constants need to start either
<ul>
<li>with an upper-case letter (<code>A-Z</code>) or an underscore (<code>_</code>) when they refer consumable values,</li>
<li>otherwise they can also start with a lower-case letter from (<code>a-z</code>).</li>
</ul>
</li>
</ol>
<p>Some examples for better understanding:</p>
<pre><code class="language-tokay"># Valid
pi : 3.1415
mul2 : @x { x * 2 }
Planet : @{ 'Venus' ; 'Earth'; 'Mars' }
the_Tribe = &quot;Apache&quot;

# Invalid
Pi : 3.1415  # float value is not consumable
planet : @{ 'Venus' ; 'Earth'; 'Mars' }  # identifier must specify consumable
The_Tribe = &quot;Cherokee&quot;  # Upper-case variable name not allowed

9th = 9  # interpreted as '9 th = 9'
</code></pre>
<p>More about <em>consumable</em> and <em>non-consumable</em> values, <em>variables</em> and <em>constants</em> will be discussed later.</p>
<h2 id="variables-and-constants"><a class="header" href="#variables-and-constants">Variables and constants</a></h2>
<p>Symbolic identifiers for named values can either be defined as <em>variables</em> or <em>constants</em>.</p>
<pre><code class="language-tokay">variable = 0  # assign 0 to a variable
constant : 0  # assign 0 to a constant
</code></pre>
<p>Obviously, this looks like the same. <code>variable</code> becomes 0 and <code>constant</code> also. Let's try to modify these values afterwards.</p>
<pre><code class="language-tokay">variable += 1  # increment variable by 1
constant += 1  # throws compile error: Cannot assign to constant 'constant'
</code></pre>
<p>Now <code>variable</code> becomes 1, but <code>constant</code> can't be assigned and Tokay throws a compile error.
What you can do is to redefine the constant with a new value.</p>
<pre><code class="language-tokay">variable++    # increment variable by 1
constant : 1  # re-assign constant to 1
</code></pre>
<p>The reason is, that variables are evaluated at runtime, whereas constants are evaluated at compile-time, before the program is being executed.</p>
<p>The distinction between variables and constants is a tradeoff between flexibility and predictivity to make different concepts behind Tokay possible. The values of variables aren't known at compile-time, therefore predictive construction of code depending on the values used is not possible. On the other hand, constants can be used before their definition, which is very useful when thinking of functions being called by other functions before their definition.</p>
<h2 id="callables-and-consumables"><a class="header" href="#callables-and-consumables">Callables and consumables</a></h2>
<p>From the object types presented above, tokens and functions have the special properties that they are <em>callable</em> and possibly <em>consumable</em>.</p>
<ul>
<li>Tokens are always callable and considered to consume input</li>
<li>Functions are always callable and are named
<ul>
<li><em>parselets</em> when they consume input by either using tokens or a consumable constant</li>
<li><em>functions</em> when they don't consume any input</li>
</ul>
</li>
</ul>
<p>For variables and constants, special naming rules apply which allow Tokay to determine a symbol type based on its identifier only.</p>
<p><em>todo: This section is a stub. More examples and detailed explanations needed here.</em></p>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>Variables and constants are organized in scopes.</p>
<ol>
<li>A scope is any block, and the global scope.</li>
<li>Constants can be defined in any block. They can be re-defined by other constants in the same or in subsequent blocks. Constants being re-defined in a subsequent block are valid until the block ends, afterwards the previous constant will be valid again.</li>
<li>Variables are only distinguished between global and local scope of a parselet. Unknown variables used in a parselet block are considered as local variables.</li>
</ol>
<p>Here's some commented code for clarification:</p>
<pre><code class="language-tokay">x = 10  # global scope variable x
y : 2000  # global scope constant y
z = 30  # global scope variable z

# entering new scope of function f
f : @x {  # x is overridden as local variable
    y : 1000  # local constant y overrides global constant y temporarily in this block
    z += y + x # adds local constant y and local value of x to global value of z
}

f(42)

# back in global scope, x is still 10, y is 2000 again, z is 1072 now.
x y z
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="values"><a class="header" href="#values">Values</a></h1>
<p>Let's discuss the meaning of values in Tokay next. Values are used everywhere, even when its not directly obvious. Generally speaking, everything in Tokay is some kind of value or part of a value.</p>
<p><em>Atomic</em> values are one of the following.</p>
<pre><code class="language-tokay">void           # values to representing just nothing
null           # values representing a defined &quot;set to null&quot;
true false     # boolean values
42 -23         # signed 64-bit integers
3.1415 -1.337  # signed 64-bit floats
&quot;Tokay 🦎&quot;     # unicode strings
</code></pre>
<p>Values can also be one of the following <em>objects</em>.</p>
<pre><code class="language-tokay"># list of values
(42, true, &quot;yes&quot;)
(42 true &quot;yes&quot;)

# dictionary (dict), a map of key-value-pairs
(i =&gt; 42, b =&gt; true, status =&gt; &quot;success&quot;)
(i =&gt; 42 b =&gt; true status =&gt; &quot;success&quot;)

# tokens are callables consuming input from the stream
'touch'    # silently touch a string in the input
''match''  # verbosely match a string from the input
[A-Z0-9]+  # matching a sequence of valid characters
Integer    # built-in token for parsing and returning Integer values

# functions and parselets are callable, enclosed blocks of code
f : @x{ x * 2 }
f(9)  # 18

@x{ x * 3 }(5)  # 15, returned by anonymous function that is called in-place
</code></pre>
<p>Objects are discussed in detail in a later chapter below.</p>
<h2 id="captures-1"><a class="header" href="#captures-1">Captures</a></h2>
<p>Items in sequences are captured during execution. They are temporarily pushed and hold onto a stack, for later access. It is possible to access previously captured items using <em>capture variables</em>. Capture variables start with a dollar-sign (<code>$</code>) followed either by an index, an aliased name or any Tokay expression which evalutes to an index or an aliased named dynamically.</p>
<p>Given the expression</p>
<pre><code class="language-tokay">first =&gt; Word  _  second =&gt; Word  _  third =&gt; Word
</code></pre>
<p>executed on the input</p>
<pre><code>Save the planet
</code></pre>
<p>the sequence and input can be broken down into the following components.</p>
<table>
    <tr>
        <td class="title">
            Capture
        </td>
        <td>
            $1
        </td>
        <td>
            $2
        </td>
        <td>
            $3
        </td>
        <td>
            $4
        </td>
        <td>
            $5
        </td>
    </tr>
    <tr>
        <td class="title">
            Alias
        </td>
        <td>
            $first
        </td>
        <td></td>
        <td>
            $second
        </td>
        <td></td>
        <td>
            $third
        </td>
    </tr>
    <tr>
        <td class="title">
            Sequence
        </td>
        <td>
            first => Word
        </td>
        <td>
            _
        </td>
        <td>
            second => Word
        </td>
        <td>
            _
        </td>
        <td>
            third => Word
        </td>
    </tr>
    <tr>
        <td class="title">
            Input
        </td>
        <td>
            "Save"
        </td>
        <td>
            " "
        </td>
        <td>
            "the"
        </td>
        <td>
            " "
        </td>
        <td>
            "Planet"
        </td>
    </tr>
    <tr>
        <td class="title">
            $0 contains
        </td>
        <td>
            "Save"
        </td>
        <td>
            "Save "
        </td>
        <td>
            "Save the"
        </td>
        <td>
            "Save the "
        </td>
        <td>
            "Save the planet"
        </td>
    </tr>
</table>
<p>As you can see, <code>$0</code> always contains the input matched so far from the start of the capture.</p>
<p>Tokay also allows to assign values to captures. This makes it possible to directly use captures like any other variable inside of the sequence and any subsequent blocks that belong to the sequence.</p>
<pre><code class="language-tokay"># planets2.tok
Name {
    if $1 == &quot;Earth&quot; {
        $1 = &quot;Home&quot;
    }
    else if $1 == &quot;Mars&quot; || $1 == &quot;Venus&quot; {
        $1 += &quot; (neighbour)&quot;
    }
}
</code></pre>
<pre><code class="language-shell">$ tokay planets2.tok -- &quot;Mercury Venus Earth Mars Jupiter&quot;
(&quot;Mercury&quot;, &quot;Venus (neighbour)&quot;, &quot;Home&quot;, &quot;Mars (neighbour)&quot;, &quot;Jupiter&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objects"><a class="header" href="#objects">Objects</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens-1"><a class="header" href="#tokens-1">Tokens</a></h1>
<p>Tokens are the fundamental building blocks used to process input. Tokay implements first-level tokens which direcly consume input, but usages of parselets, which are functions consuming input, are considered as second-level tokens, and are at least tokens as well.</p>
<h2 id="touch--match"><a class="header" href="#touch--match">Touch &amp; match</a></h2>
<p>To match exact strings of characters from the input, like keywords, the <em>match</em> and <em>touch</em> token-type is used. Touch was yet mostly used in our examples, but match is also useful, depending on use-case.</p>
<pre><code class="language-tokay">'Touch'    # match string in the input and discard
''Match''  # match string in the input and take
</code></pre>
<p>The only difference between the two types is, that a match has a higher severity than a touch, and will be recognized within automatic value construction.
Both type of matches can be referred by capture variables, therefore</p>
<pre><code class="language-tokay">'Match' $1
</code></pre>
<p>is the same result like a direct match.</p>
<p>Check out the following one-liner when executed on the input <code>1+2-3+4</code>, it will return <code>(1, &quot;+&quot;, (2, (3, &quot;+&quot;, 4)))</code>. The matches on the plus (<code>''+''</code>) is taken into the result, the touch on minus (<code>'-'</code>) are discarded.</p>
<pre><code class="language-tokay">E : { E ''+'' E ; E '-' E; Integer }; E
</code></pre>
<h2 id="character-classes"><a class="header" href="#character-classes">Character-classes</a></h2>
<p>Character tokens are expressed as character-classes known from regular expressions. They are encapsulated in brackets <code>[...]</code> and allow for a specification of ranges or single characters.</p>
<ul>
<li>Single Characters are either specified by a Unicode-character or an escape sequence</li>
<li>Ranges are delimited by a dash (<code>-</code>). If a Max-Min-Range is specified, it is automatically converted into a Min-Max-Range, so <code>[z-a]</code> becomes <code>[a-z]</code>.</li>
<li>If a dash (<code>-</code>) should be part of the character-class, it should be specified first or last.</li>
<li>If a circumflex (<code>^</code>) is specified as first character in the character-class, the character-class will be inverted, so <code>[^a-z]</code> matches everything except <code>a</code> to <code>z</code>.</li>
</ul>
<pre><code class="language-tokay">[a]           # just &quot;a&quot;
[az]          # either &quot;a&quot; or &quot;z&quot;
[abc]         # &quot;a&quot;, &quot;b&quot; or &quot;c&quot;
[a-c]         # &quot;a&quot;, &quot;b&quot; or &quot;c&quot; also
[a-zA-Z0-9_]  # All ASCII digit or letter and underscore
[^0-9]        # Any character except ASCII digits
[-+*/]        # Mathematical base operators (minus-dash first!)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parselets"><a class="header" href="#parselets">Parselets</a></h1>
<h2 id="begin-end"><a class="header" href="#begin-end">begin, end</a></h2>
<p><em>coming soon</em></p>
<h2 id="accept-reject"><a class="header" href="#accept-reject">accept, reject</a></h2>
<p><em>coming soon</em></p>
<h2 id="repeat"><a class="header" href="#repeat">repeat</a></h2>
<p><em>coming soon</em></p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>A function is introduced by an at-character (<code>@</code>), where a parameter list might optionally follow. The function's body is obgligatory, but can also exist of just a sequence or an item. Functions are normally assigned to constants, but can also be assigned to variables, with some loose of flexibility, but opening other features.</p>
<pre><code class="language-tokay"># f is a function
f : @x = 1 {
    print(&quot;I am a function, x is &quot; + x)
}

f        # calls f, because it has no required parameters!
f()      # same as just f
f(5)     # calls f with x=5
f(x=10)  # calls f with x=10
</code></pre>
<p>Tokay functions that consume input are called <em>parselets</em>. It depends on the function's body if its either considered to be a function or a parselet. Generally, when talking about parselets in Tokay, both function and real parselets are meant as shorthand.</p>
<pre><code class="language-tokay"># P is a parselet, as it uses a consuming token
P : @x = 1 {
    Word print(&quot;I am a parselet, x is &quot; + x)
}

P        # calls P, because it has no required parameters!
P()      # same as just P
P(5)     # calls P with x=5
P(x=10)  # calls P with x=10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-structures"><a class="header" href="#control-structures">Control structures</a></h1>
<p>In comparison to many other languages, control structures in Tokay are part of expressions. They always return a value, which defaults to <code>void</code> when no other value is explicitly returned.</p>
<h2 id="ifelse"><a class="header" href="#ifelse">if...else</a></h2>
<p>The <code>if...else</code>-construct implements conditional branching depending on the result of an expression.<br>
The <code>else</code> part is optional, and can be omitted.</p>
<pre><code class="language-tokay">if sense == 42 &amp;&amp; axis == 23.5 {
    print(&quot;Well, this is fine!&quot;)
}
else {
    print(&quot;That's quite bad.&quot;)
}
</code></pre>
<p>As stated before, all control structures are part of Tokays expression syntax. Above example can easily by turned into</p>
<pre><code class="language-tokay">print(
    if sense == 42 &amp;&amp; axis == 23.5
        &quot;Well, this is fine!&quot;
    else
        &quot;That's quite bad.&quot;
)
</code></pre>
<p>or directly used inside of an expression.</p>
<pre><code class="language-tokay"># if can be part of an expression
Word &quot;Hello &quot; + if $1 == &quot;World&quot; &quot;Earth&quot; else $1
</code></pre>
<p><code>if...else</code> constructs working on static expressions are optimized away during compile-time.</p>
<h2 id="loop"><a class="header" href="#loop">loop</a></h2>
<p>The <code>loop</code>-keyword is used to create loops, either with an aborting conditions on top or without any condition.</p>
<pre><code class="language-tokay"># Countdown
count = 10
loop count &gt;= 0 print(
    if --count == 3
        &quot;Ignition&quot;
    else if count &lt; 0
        &quot;Liftoff&quot;
    else
        count
)
</code></pre>
<p>A loop can be aborted everytime using the <code>break</code>-statement.<br>
The <code>continue</code>-statement restarts the loop at the beginning, but a present abort-condition will be re-checked again.</p>
<pre><code class="language-tokay">count = 10
loop {
    count = count - 1
    if count == 3 {
        print(&quot;Ignition&quot;)
        continue
    }

    print(count)
    if count == 0 {
        print(&quot;Liftoff&quot;)
        break
    }
}
</code></pre>
<p>A loop without any aborting condition loops forever.</p>
<pre><code class="language-tokay">loop print(&quot;Forever!&quot;)
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>The <code>for</code>-keyword introduces a special form of loop that syntacically glues the parts <em>initialization</em>, <em>abort condition</em> and <em>iteration</em> together into a separate syntactic element.</p>
<pre><code class="language-tokay">for count = 10; count &gt;= 0; count-- {
    print(i)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-keywords"><a class="header" href="#appendix-a-keywords">Appendix A: Keywords</a></h1>
<p>In Tokay, the following keywords are reserved words for control structures, values and special operators.</p>
<ul>
<li><code>accept</code> - accept parselet, optionally with a return value</li>
<li><code>begin</code> - sequence to execute at begining of a parselet</li>
<li><code>break</code> - break from a loop, optonally with a return value</li>
<li><code>continue</code> - restart iteration in a loop</li>
<li><code>else</code> - fallback for <code>if</code> constructs</li>
<li><code>end</code> - sequence to execute at end of a parselet</li>
<li><code>exit</code> - stop program execution, optional with exit code</li>
<li><code>expect</code> - operator for consumable that expects the consumable and throws an error if not present</li>
<li><code>false</code> - the <em>false</em> value</li>
<li><code>for</code> - head-controlled <code>for</code> loop</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>in</code> - part of the <code>for</code>-loop syntax</li>
<li><code>loop</code> - head-controlled loop with an optional abort conition</li>
<li><code>next</code> - continue with next sequence in a block</li>
<li><code>not</code> - operator for consumable that satisfies when the consumable is not consumed</li>
<li><code>null</code> - the <em>null</em> value</li>
<li><code>peek</code> - operator for consumable that satisfies when consumable is consumed but the reader rolls back afterwards</li>
<li><code>push</code> - accept a sequence by pushing a value</li>
<li><code>reject</code> - reject parselet as not being consumed</li>
<li><code>repeat</code> - repeat parselet, optionally push a result</li>
<li><code>return</code> - same like <code>accept</code>, but with a meaning for ordinary functions</li>
<li><code>true</code> - the <em>true</em> value</li>
<li><code>void</code> - the <em>void</em> value</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-operators"><a class="header" href="#appendix-b-operators">Appendix B: Operators</a></h1>
<p>Tokay implements the following operators for use in expressions. The operators are ordered by precedence, operators in the same row share the same precedence.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Operator
            </th>
            <th>
                Description
            </th>
            <th>
                Associativity
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>= += -= *= /=</td>
            <td>Assignment, combined operation-assignment</td>
            <td>left</td>
        </tr>
        <tr>
            <td>||</td>
            <td>Logical or</td>
            <td>left</td>
        </tr>
        <tr>
            <td>&&</td>
            <td>Logical and</td>
            <td>left</td>
        </tr>
        <tr>
            <td>== != < <= >= ></td>
            <td>Equal, unequal, Comparison</td>
            <td>left</td>
        </tr>
        <tr>
            <td>+ -</td>
            <td>Add, subtract</td>
            <td>left</td>
        </tr>
        <tr>
            <td>* /</td>
            <td>Multiply, divide</td>
            <td>left</td>
        </tr>
        <tr>
            <td>- !</td>
            <td>Negate, not</td>
            <td>right</td>
        </tr>
        <tr>
            <td>++ --</td>
            <td>Increment, decrement</td>
            <td>right</td>
        </tr>
        <tr>
            <td>() [] .</td>
            <td>Grouping, subscript, attribute</td>
            <td>left</td>
        </tr>
    </tbody>
</table>
<p>Operators produce different results depending on the data-types of their operands. For example, <code>3 * 10</code> multiplies 10 by 3, whereas <code>3 * &quot;test&quot;</code> creates a new string repeating &quot;test&quot; 3 times. Try out the results of different operands in a Tokay REPL for clarification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c-modifiers"><a class="header" href="#appendix-c-modifiers">Appendix C: Modifiers</a></h1>
<p>Tokay allows to use the following modifiers for calls to consumable values. Modifiers are used to describe repetitions or optional occurences of consumables.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Modifier
            </th>
            <th>
                Description
            </th>
            <th>
                Examples
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>+</td>
            <td>Positive repetition (one or many)</td>
            <td>`'t'+, P(n=3)+`</td>
        </tr>
        <tr>
            <td>?</td>
            <td>Optional (one or none)</td>
            <td>`'t'?, P(n=3)?`</td>
        </tr>
        <tr>
            <td>*</td>
            <td>Kleene star (none or many)</td>
            <td>`'t'*, P(n=3)*`</td>
        </tr>
    </tbody>
</table>
<h2 id="redudancy-with-expressional-operators"><a class="header" href="#redudancy-with-expressional-operators">Redudancy with expressional operators</a></h2>
<p>You might have noticed that the operators <code>+</code> and <code>*</code> are used as operators for add and multiply as well. To clarify meaning, all modifiers stick to the token they belong to, and no whitespace is accepted between them. Modifiers are only allowed on tokens and parselet calls, and nowhere else, as it makes no sense.</p>
<p>Here are some examples for clarification:</p>
<pre><code class="language-tokay">'t' * 3    # match 't' and repeat the result 3 times
't'* * 3   # match 't' one or multiple times and repeat the result 3 times
't' * * 3  # syntax error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-builtins"><a class="header" href="#appendix-d-builtins">Appendix D: Builtins</a></h1>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h2 id="tokens-2"><a class="header" href="#tokens-2">Tokens</a></h2>
<p>The following tokens are built into Tokay and can be used immediatelly. Programs can override these constants on-demand.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Token
            </th>
            <th>
                Token+
            </th>
            <th>
                Description
            </th>
        </tr>
    </thead>
    <tbody>
        <tr><td>Alphabetic</td><td>Alphabetics</td><td>All Unicode characters having the Alphabetic property</td></tr>
        <tr><td>Alphanumeric</td><td>Alphanumerics</td><td>The union of Alphabetic and Numeric</td></tr>
        <tr><td>Any / .</td><td>-</td><td>Any character, except EOF</td></tr>
        <tr><td>Ascii</td><td>Asciis</td><td>All characters within the ASCII range.</td></tr>
        <tr><td>AsciiAlphabetic</td><td>AsciiAlphabetics</td><td>All ASCII alphabetic characters <code>[A-Za-z]</code></td></tr>
        <tr><td>AsciiAlphanumeric</td><td>AsciiAlphanumerics</td><td>ASCII alphanumeric characters <code>[0-9A-Za-z]</code></td></tr>
        <tr><td>AsciiControl</td><td>AsciiControls</td><td>All ASCII control characters <code>[\x00-\x1F\x7f]</code>. SPACE is not a control character.</td></tr>
        <tr><td>AsciiDigit</td><td>AsciiDigits</td><td>ASCII decimal digits <code>[0-9]</code></td></tr>
        <tr><td>AsciiGraphic</td><td>AsciiGraphics</td><td>ASCII graphic character <code>[!-~]</code></td></tr>
        <tr><td>AsciiHexdigit</td><td>AsciiHexdigits</td><td>ASCII hex digits <code>[0-9A-Fa-f]</code></td></tr>
        <tr><td>AsciiLowercase</td><td>AsciiLowercases</td><td>All ASCII lowercase characters <code>[a-z]</code></td></tr>
        <tr><td>AsciiPunctuation</td><td>AsciiPunctuations</td><td>All ASCII punctuation characters <code>[-!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~]</code></td></tr>
        <tr><td>AsciiUppercase</td><td>AsciiUppercases</td><td>All ASCII uppercase characters <code>[A-Z]</code></td></tr>
        <tr><td>AsciiWhitespace</td><td>AsciiWhitespaces</td><td>All characters defining ASCII whitespace <code>[ \t\n\f\r]</code></td></tr>
        <tr><td>Control</td><td>Controls</td><td>All Unicode characters in the controls category</td></tr>
        <tr><td>Digit</td><td>Digits</td><td>ASCII decimal digits <code>[0-9]</code></td></tr>
        <tr><td>EOF</td><td>-</td><td>Matches End-Of-File.</td></tr>
        <tr><td>Lowercase</td><td>Lowercases</td><td>All Unicode characters having the Lowercase property</td></tr>
        <tr><td>Numeric</td><td>Numerics</td><td>All Unicode characters in the numbers category</td></tr>
        <tr><td>Uppercase</td><td>Uppercases</td><td>All Unicode characters having the Uppercase property</td></tr>
        <tr><td>Whitespace</td><td>Whitespaces</td><td>All Unicode characters having the White_Space property</td></tr>
        <tr><td>Void</td><td>-</td><td>The empty token, which consuming nothing, but consumes!</td></tr>
    </tbody>
</table>
<p>The respective properties of the built-in character classes is described in Chapter 4 (Character Properties) of the <a href="https://www.unicode.org/versions/latest/">Unicode Standard</a> and specified in the <a href="https://www.unicode.org/reports/tr44">Unicode Character Database</a> in <a href="https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt">DerivedCoreProperties.txt</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-e-escape-sequences"><a class="header" href="#appendix-e-escape-sequences">Appendix E: Escape sequences</a></h1>
<p>Escape sequences can be used inside of strings, match/touch tokens and character-classes to encode any unicode character. They are introduced with a backslash.</p>
<p>Escape-sequences should be used to simplify the source code and its readability, but any unicode character can also be directly expressed.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Sequence
            </th>
            <th>
                Description
            </th>
            <th>
                Examples
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>\a \b \f \n \r \t \v</td>
            <td>Bell (alert), backspace, formfeed, new line, carriage return, horizontal tab, vertical tab, </td>
            <td>"\a\b\f\n\r\t\v"</td>
        </tr>
        <tr>
            <td>\' \" \\</td>
            <td>Quotation marks, backslash</td>
            <td>"\'\"\\"  # '"\</td>
        </tr>
        <tr>
            <td>\ooo</td>
            <td>ASCII character in octal notation</td>
            <td>"\100"  # @</td>
        </tr>
        <tr>
            <td>\xhh</td>
            <td>ASCII character in hexadecimal notation</td>
            <td>"\xCA"  # Ê</td>
        </tr>
        <tr>
            <td>\uhhhh</td>
            <td>16-Bit Unicode character in hexadecimal notation</td>
            <td>"\u20ac"  # €</td>
        </tr>
        <tr>
            <td>\Uhhhhhhhh</td>
            <td>32-Bit Unicode character in hexadecimal notation</td>
            <td>"\U0001F98E"  # 🦎</td>
        </tr>
    </tbody>
</table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
