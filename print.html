<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tokay programming language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">1.</strong> Preface</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li class="chapter-item expanded "><a href="basics/index.html"><strong aria-hidden="true">3.</strong> Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="basics/items.html"><strong aria-hidden="true">3.1.</strong> Items</a></li><li class="chapter-item expanded "><a href="basics/sequences.html"><strong aria-hidden="true">3.2.</strong> Sequences</a></li><li class="chapter-item expanded "><a href="basics/blocks.html"><strong aria-hidden="true">3.3.</strong> Blocks</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/index.html"><strong aria-hidden="true">4.</strong> Concepts</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="concepts/terminology.html"><strong aria-hidden="true">4.1.</strong> Terminology</a></li><li class="chapter-item expanded "><a href="concepts/values.html"><strong aria-hidden="true">4.2.</strong> Values</a></li><li class="chapter-item expanded "><a href="concepts/tokens.html"><strong aria-hidden="true">4.3.</strong> Tokens</a></li><li class="chapter-item expanded "><a href="concepts/parselets.html"><strong aria-hidden="true">4.4.</strong> Parselets</a></li></ol></li><li class="chapter-item expanded "><a href="control-structures.html"><strong aria-hidden="true">5.</strong> Control structures</a></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">6.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix/keywords.html"><strong aria-hidden="true">6.1.</strong> A - Keywords</a></li><li class="chapter-item expanded "><a href="appendix/operators.html"><strong aria-hidden="true">6.2.</strong> B - Operators</a></li><li class="chapter-item expanded "><a href="appendix/modifiers.html"><strong aria-hidden="true">6.3.</strong> C - Modifiers</a></li><li class="chapter-item expanded "><a href="appendix/builtins.html"><strong aria-hidden="true">6.4.</strong> D - Builtins</a></li><li class="chapter-item expanded "><a href="appendix/escape-sequences.html"><strong aria-hidden="true">6.5.</strong> E - Escape sequences</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Tokay programming language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<blockquote>
<p>This documentation was updated to be used with <a href="https://tokay.dev/news/release-v0-6/">Tokay 0.6</a>.<br>
Some features might not work as expected when used with a more recent version.</p>
</blockquote>
<blockquote>
<p>Likewise Tokay itself, this documentation is currently under development and unfinished.<br>
If you found any mistakes or can explain things better, please contribute!<br>
To do so, visit <a href="https://github.com/tokay-lang">https://github.com/tokay-lang</a>.</p>
</blockquote>
<p>Tokay is a programming language designed for ad-hoc parsing and text processing. Tokay programs operate directly on input streams that are read from files, strings, piped commands or any other device emitting characters.</p>
<p>The following example is a short Tokay program that illustrates how Tokay works. It recognizes either &quot;Hello Mercury&quot;, &quot;Hello Venus&quot; or &quot;Hello Earth&quot; from a text stream. Any other input is automatically skipped.</p>
<pre><code class="language-tokay">'Hello' _ {
    'Mercury'
    'Venus'
    'Earth'
}
</code></pre>
<p>Unlike general purpose programming languages like Rust or Python, in Tokay no explicit branching, substring extraction, or reading from input is required. Instead, these operations are directly built into the language.</p>
<p>If you're familiar with <a href="https://en.wikipedia.org/wiki/AWK">AWK</a>, you might find the syntax in the previous example to be similar to the <code>PATTERN { action }</code> syntax. This approach is recursive in Tokay, so that the action-part can also be treated as a pattern, or as plain action code. This highlights a core tenet of Tokay's design and its key difference from AWK: instead of using a line-based execution model, Tokay takes a token-based approach that permits operating on anything matched from the input. This enables Tokay programs to operate on recursive structures that can be expressed by a grammar.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h1>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>Currently, Tokay is in a very early project state. Therefore you have to built it from source, using the <a href="https://www.rust-lang.org/">Rust</a> programming language and its build-tool <code>cargo</code>.</p>
<p>Once you got Rust installed, install <a href="https://crates.io/crates/tokay">Tokay</a> by</p>
<pre><code class="language-bash">$ cargo install tokay
</code></pre>
<p>Once done, you should run the Tokay REPL with</p>
<pre><code class="language-bash">$ tokay
Tokay 0.6.0
&gt;&gt;&gt; print(&quot;Hello Tokay&quot;)
Hello Tokay
&gt;&gt;&gt;
</code></pre>
<p>You can exit the Tokay REPL with <code>Ctrl+C</code>.</p>
<blockquote>
<p>The next examples are showing the REPL-prompt <code>&gt;&gt;&gt;</code> with a given input and output. The output may differ when other input is provided.</p>
</blockquote>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Invoking the <code>tokay</code> command without any arguments starts the REPL (read-eval-print-loop). This allows to enter expressions or even full programs interactively with a direct result.</p>
<pre><code class="language-bash"># Start a repl
$ tokay

# Start a repl working on an input stream from file.txt
$ tokay -- file.txt

# Start a repl working on the input string &quot;gliding is flying with the clouds&quot;
$ tokay -- &quot;gliding is flying with the clouds&quot;
Tokay 0.6.0
&gt;&gt;&gt; Word(5)
(&quot;gliding&quot;, &quot;flying&quot;, &quot;clouds&quot;)
&gt;&gt;&gt;
</code></pre>
<blockquote>
<p>In case you compile and run Tokay from source, use <code>cargo run --</code> with any desired parameters here, instead of the <code>tokay</code> command.</p>
</blockquote>
<p>Next runs the Tokay program from the file <em>program.tok</em>:</p>
<pre><code class="language-bash"># Run a program from a file
$ tokay program.tok
</code></pre>
<p>To directly work on files as input stream, do this as shown next. Further files can be specified and are executed on the same program sequentially. Its also possible to read from stdin using the special filename <code>-</code>.</p>
<pre><code class="language-bash"># Run a program from a file with another file as input stream
$ tokay program.tok -- file.txt

# Run a program from with multiple files as input stream
$ tokay program.tok -- file1.txt file2.txt file3.txt

# Run a program from with files or strings as input stream
$ tokay program.tok -- file1.txt &quot;gliding is fun&quot; file2.txt

# Pipe input through tokay
$ cat file.txt | tokay program.tok -- -
</code></pre>
<p>A Tokay program can also be specified directly as first parameter. This call just prints the content of the files specified:</p>
<pre><code class="language-bash"># Directly provide program via command-line parameter
$ tokay 'print(Char+)' -- file.txt
</code></pre>
<blockquote>
<p><code>tokay --help</code> will give you an overview about further parameters and invocation.</p>
</blockquote>
<h2 id="first-steps"><a class="header" href="#first-steps">First steps</a></h2>
<p>Tokay programs are made of <em>items</em>, <em>sequences</em> and <em>blocks</em>.</p>
<h3 id="items"><a class="header" href="#items">Items</a></h3>
<p>An item can be an expression, a function or token call or a statement. The following are all items.</p>
<pre><code class="language-tokay"># Expression
&gt;&gt;&gt; 2 + 3 * 5
17

# Assignment of an expression to a variable
&gt;&gt;&gt; i = 2 + 3 * 5

# Using a variable within an expression
&gt;&gt;&gt; i + 3
20

# Conditional if-statement
&gt;&gt;&gt; if i == 17 &quot;yes&quot; else &quot;no&quot;
&quot;yes&quot;

# Function call
&gt;&gt;&gt; print(&quot;hello&quot; + i)
hello17

# Method call
&gt;&gt;&gt; &quot;hello&quot;.upper * 3
&quot;HELLOHELLOHELLO&quot;

# Token call (&quot;hello&quot; is read by Word(3) from the input stream)
&gt;&gt;&gt; Word(3)
&quot;hello&quot;

# Token call in an expression (42 is read by Int from the input stream)
&gt;&gt;&gt; Int * 3
126
</code></pre>
<h3 id="sequences"><a class="header" href="#sequences">Sequences</a></h3>
<p>Sequences are multiple items in a row. Items in a sequence can optionally be separated by commas, but this is not mandatory. Sequences are either delimited by line-break, or a semicolon (<code>;</code>).</p>
<pre><code class="language-tokay"># A sequence of items with the same weighting result in a list
&gt;&gt;&gt; 1 2 3
(1, 2, 3)

# This works also comma-separated
&gt;&gt;&gt; 1, 2, 3
(1, 2, 3)

# This is a sequence of lists (indeed, lists are sequences, too)
&gt;&gt;&gt; (1 2 3) (4 5 6)
((1, 2, 3), (4, 5, 6))

# Two sequences in one row; only last result is printed in REPL.
&gt;&gt;&gt; (1 2 3); (4 5 6)
(4, 5, 6)

# This is a simple parsing sequence, accepting  assignments like
# &quot;i=1&quot; or &quot;number = 123&quot;
&gt;&gt;&gt; Ident _ '=' _ Int
(&quot;number&quot;, 123)

# This is a version of the same sequence constructing a dictionary
# rather than a list
&gt;&gt;&gt; name =&gt; Ident _ '=' _ value =&gt; Int
(name =&gt; &quot;number&quot;, value =&gt; 123)
</code></pre>
<h3 id="blocks"><a class="header" href="#blocks">Blocks</a></h3>
<p>Finally, sequences are organized in blocks. The execution of a sequence is influenced by failing token matches or special keywords (like <code>push</code>, <code>next</code> or <code>accept</code>, <code>reject</code>, etc.), which either enforce to execute the next sequence, or accept or reject a parselet, which can be referred to as a function. The main-parselet is also a parselet executing the main block, where the REPL runs in.</p>
<p>A block itself is also an item inside of a sequence of another block (or the main block). A new block is defined by <code>{</code> and <code>}</code>.</p>
<p>The next piece of code is already a demonstration of Tokays parsing features together with a parselet and two blocks, implementing an assignment grammar for either float or integer values, and some error reporting.</p>
<pre><code class="language-tokay"># Parselet definition of Assignment (identified by the @{...}-block)
# Match an identifier, followed by either a float or an integer;
# Throws an error on mismatch.
&gt;&gt;&gt; Assignment : @{
    Ident _ '=' _ {
        Float
        Int
        error(&quot;Expecting a number here&quot;)
    }
}

# Given input &quot;i = 23.5&quot;
&gt;&gt;&gt; Assignment
(&quot;i&quot;, 23.5)

# Given input &quot;i = 42&quot;
&gt;&gt;&gt; Assignment
(&quot;i&quot;, 42)

# Given input &quot;i = j&quot;
&gt;&gt;&gt; Assignment
Line 1, column 5: Expecting a number here
</code></pre>
<h3 id="writing-comments"><a class="header" href="#writing-comments">Writing comments</a></h3>
<p>It is good practise to document source code and what's going on using comments. Likewise bash, Python or awk, Tokay supports line-comments starting with a hash (<code>#</code>). The rest of the line will be ignored.</p>
<pre><code class="language-tokay"># This is my little program

print(&quot;Hello World&quot;)  # printing welcome message to the user
hash = &quot;# this is a string&quot;  # assign &quot;# this is a string&quot; to hash.
</code></pre>
<h3 id="shebang"><a class="header" href="#shebang">Shebang</a></h3>
<p>Therefore a shebang is also possible in case a Tokay source file shall be directly executable.</p>
<pre><code class="language-tokay">#!/bin/tokay
print(&quot;Hello World&quot;)
</code></pre>
<p>This assumes <code>tokay</code> is installed to <code>/bin</code> on a Posix-like system.</p>
<pre><code class="language-bash">$ ls -lta hello.tok
-rwxr-xr-x  hello.tok
$ ./hello.tok
Hello World
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics"><a class="header" href="#basics">Basics</a></h1>
<p>Basically, a Tokay program is made of</p>
<ul>
<li>Items</li>
<li>Sequences</li>
<li>Blocks</li>
</ul>
<p>All these belong together and depend on each other in some way.</p>
<p>The following program demonstrates the usage of <em>items</em>, <em>sequences</em> and <em>blocks</em> in action:</p>
<pre><code class="language-tokay">{ # A block...
    # ... is made of sequences
    'Hello' _ Name \
        count_hello++   # ... which are made of items (4 items here).

    'Goodbye' _ {  # an item of a sequence can be a block again
        'Max'  count_bye_max++  # ... which contains other sequences...
        Name   count_bye++      # ... made of items again.
    }

    {}  # a sequence with an empty block as its item
}
</code></pre>
<p>This program is a little parser, which looks for greetings in some input.</p>
<ul>
<li>The occurence of e.g. <code>Hello Jan</code> and <code>Hello Max</code> causes the variable<code>count_hello</code> to be incremented</li>
<li>The occurence of e.g. <code>Goodbye Jan</code> increments the counter <code>count_bye</code>, but</li>
<li>An occurence of <code>Goodbye Max</code>, which is a special case here, counts on <code>count_bye_max</code>.</li>
</ul>
<blockquote>
<p>If you are familiar with the <em>AWK programming language</em>, you might see some similarities to the <code>PATTERN { action }</code>-syntax here.</p>
<p>In Tokay, <em>PATTERN</em> can be any sequence of items that need to match before, and <em>{ action }</em> can hold further <code>PATTERN { action }</code>-components.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="items-1"><a class="header" href="#items-1">Items</a></h1>
<p>Items are the atomic parts of sequences, and represent values.</p>
<p>The following examples for items are direct values that, once specified, stay on their own.</p>
<pre><code class="language-tokay">123               # the number 123
true              # the boolean value for truth
&quot;Tokay ðŸ¦Ž&quot;        # a unicode string
</code></pre>
<p>Items can also be the result of expressions or calls to callable objects.</p>
<pre><code class="language-tokay">&quot;a &quot; + &quot;string&quot;   # concatenating a string
42 * 23.5         # the result of a multiplication
'check'           # the occurence of string &quot;check&quot; in the input
Integer           # calling a built-in token for parsing integer values
func(42)          # calling a function
++count           # the incremented value of count
</code></pre>
<p>But items can also be more complex.</p>
<pre><code class="language-tokay">x = count * 23.5  # the result of a calculation is assigned to a variable
</code></pre>
<p>This is an assignment, and always produces the item value <code>void</code>, which means just &quot;nothing&quot;. This is, because the result of the calculation is stored to a variable, but the item must represent some value.</p>
<p>Here's another item:</p>
<pre><code class="language-tokay">if x &gt; 100 &quot;much&quot; # conditional expression, which is either &quot;much&quot; or void
</code></pre>
<p>This <code>if</code>-clause allows for conditional programming. It either produces a string when the provided condition is met, and otherwise also produces <code>void</code>.</p>
<p>This behavior can be changed by providing an <code>else</code>-branch next, like this:</p>
<pre><code class="language-tokay">if x &gt; 100 &quot;much&quot; else &quot;less&quot;
</code></pre>
<p>As you see, every single value, call, expression or control-flow statement is considered to be an item.</p>
<p>A <a href="basics/blocks.html">block</a> is also an item as well, but this will be disussed later.</p>
<h2 id="severities"><a class="header" href="#severities">Severities</a></h2>
<blockquote>
<p>This is not important for the first steps and programs with Tokay, but a fundamental feature of the magic behind Tokay's automatic value construction features, which will be discussed later. You should know about it!</p>
</blockquote>
<p>Every item has a severity, which defines its value's &quot;weight&quot;.</p>
<p>Tokay currently knows 4 levels of severitity:</p>
<ol>
<li>Whitespace</li>
<li>Match</li>
<li>Value</li>
<li>Result</li>
</ol>
<p>The severity of an item depends on how it is constructed. For example</p>
<pre><code class="language-tokay">123               # pushes 123 with severity 3
_                 # matches whitespace
'check'           # matches &quot;check&quot; in input and pushes it considered as match
''check''         # matches &quot;check&quot; in input and pushes it considered as value
'check' * 3       # matches &quot;check&quot; in input and repeats it 3 times, resuling in value
push &quot;yes&quot;        # pushes result value &quot;yes&quot;
</code></pre>
<p>Right now, this isn't so important, and you shouldn't keep this in mind all the time. It will become useful during the next chapters, and especially when writing programs that parse or extract data off something.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In conclusion, an item is the result of some expression which always stands for a value. An item in turn is part of a sequence. Every item has a hidden severity, which is important for constructing values from sequences later on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequences-1"><a class="header" href="#sequences-1">Sequences</a></h1>
<p>Sequences are occurences of items in a row.</p>
<p>Here is a sequence of three items:</p>
<pre><code class="language-tokay">1 2 3 + 4    # results in a list (1, 2, 7)
</code></pre>
<p>For better readability, items of a sequence can be optionally separated by commas (<code>,</code>), so</p>
<pre><code class="language-tokay">1, 2, 3 + 4  # (1, 2, 7)
</code></pre>
<p>encodes the same.</p>
<p>All items of a sequence with a given severity are used to determine the result of the sequence. Therefore, these sequences return <code>(1, 2, 7)</code> in the above examples when entered in a Tokay REPL. This has to deal with the <a href="basics/items.html#severities">severities</a> the items own.</p>
<p>The end of the sequence is delimited by a line-break, but the sequence can be wrapped into to multiple using a backslash before the line-break. So</p>
<pre><code class="language-tokay">1, 2 \
3 + 4  # (1, 2, 7)
</code></pre>
<p>means also the same as above.</p>
<h2 id="captures"><a class="header" href="#captures">Captures</a></h2>
<p>The already executed items of a sequence are captured, so they can be accessed inside of the sequence using <em>capture variables</em>.</p>
<p>In the next example, the first capture, which holds the result <code>7</code> from the expression <code>3 + 4</code> is referenced with <code>$1</code> and used in the second item as value of the expression. Referencing a capture which is out of bounds will just return <code>void</code>.</p>
<pre><code class="language-tokay">3 + 4, $1 * 2  # (7, 14)
</code></pre>
<p>Captures can also be re-assigned by subsequent items. The next one assigns a value at the second item to the first item, and uses the first item inside of the calculation. The second item which is the assignment, exists also as item of the sequence and refers to <code>void</code>, as all assignments do.</p>
<blockquote>
<p>This is the reason why Tokay has two values to simply define nothing, which are <code>void</code> and <code>null</code>, but <code>null</code> has a higher precedence.</p>
</blockquote>
<pre><code class="language-tokay">3 + 4, $1 = $1 * 2  # 14
</code></pre>
<p>As the result of the above sequence, just one value results which is <code>14</code>, but the second item's value, <code>void</code>, has a lower severity than the calculated and assigned first value. This is the magic with sequences that you will soon figure out in detail, especially when tokens from streams are accessed and processed, or your programs work on extracted information from the input, and the automatic abstract syntax tree construction occurs.</p>
<p>As the last example, we shortly show how sequence items can also be named and accessed by a more meaningful name than just the index.</p>
<pre><code class="language-tokay">hello =&gt; &quot;Hello&quot;, $hello = 3 * $hello  # (hello =&gt; &quot;HelloHelloHello&quot;)
</code></pre>
<p>Here, the first item, which is referenced by the capture variable <code>$hello</code> is repeated 3 times as the second item.</p>
<p>It might be quite annoying, but the result of this sequence is a <em>dict</em> as shown in the comment. A dict is a hash-table where values can be referenced by a key.</p>
<blockquote>
<p>If you come from Python, you might already know about <em>list</em> and <em>dict</em> objects. Their behavior and meaning is similar in Tokay.</p>
</blockquote>
<h2 id="parsing-input-sequences"><a class="header" href="#parsing-input-sequences">Parsing input sequences</a></h2>
<p>As Tokay is a programming language with built-in parsing capabilities, let's see how parsing integrates to sequences and captures.</p>
<p>Given the sequence</p>
<pre><code class="language-tokay">Word __ ''the'' __ Word
</code></pre>
<p>we make use of the built-in token <code>Word</code> which matches anything made of characters and digits, and the special constant <code>__</code>, which matches arbitrary whitespace, but at least one whitespace character must be present. Whitespace is anything represented by non-printable characters, like spaces or tabs.</p>
<p>We can now run this sequence on any input existing of three words, where the word in the middle is &quot;the&quot;. Let's say</p>
<pre><code>Save the planet
</code></pre>
<p>and we get the output</p>
<pre><code>(&quot;Save&quot;, &quot;the&quot;, &quot;planet&quot;)
</code></pre>
<blockquote>
<p>To try it out, either start a Tokay REPL with <code>$ tokay -- &quot;Save the planet&quot;</code> and enter the sequence <code>Word __ ''the'' __ Word</code> afterwards, or directly specify both at invocation, like<br>
<code>$ tokay &quot;Word __ ''the'' __ Word&quot; -- &quot;Save the planet&quot;</code>.</p>
</blockquote>
<p>You will see, it's regardless of how many whitespace you insert, the result will always be the same. The reason for this are the item <a href="basics/items.html#severities">severities</a> discussed earlier. Whitespace, used by the pre-defined constant <code>__</code>, has a lower severity, and therefore won't make it in the result of the sequence.</p>
<h3 id="using-capture-aliases"><a class="header" href="#using-capture-aliases">Using capture aliases</a></h3>
<p>Captures can also have a name, called &quot;alias&quot;. This is ideal for parsing, to give items meaningful names and make them independent from their position.</p>
<pre><code class="language-tokay">predicate =&gt; Word __ 'the' __ object =&gt; Word
</code></pre>
<p>will output</p>
<pre><code>(object =&gt; &quot;planet&quot;, predicate =&gt; &quot;Save&quot;)
</code></pre>
<blockquote>
<p>In this example, the match for the word <code>''the''</code> was degrated to a touch <code>'the'</code>, which has a lower item severity and won't make it into the sequence result.</p>
<p>This was done to make the output more clear, and because &quot;the&quot; is only an article without relevance to the meaning of the sentence we try to parse.</p>
</blockquote>
<p>Now we can also work with alias variables inside of the sequence</p>
<pre><code class="language-tokay">predicate =&gt; Word __ 'the' __ object =&gt; Word \
    print(&quot;What to &quot; + $predicate.lower() + &quot;? The &quot; + $object + &quot;!&quot;)
</code></pre>
<p>will output</p>
<pre><code>What to save? The planet!
</code></pre>
<p>The advantage here is, that we can change the sequence to further items in between, and don't have to change all references to these items in the print function call, because they are identified by name, and not by their offset, which might have changed.</p>
<h3 id="the-capture-variable-0"><a class="header" href="#the-capture-variable-0">The capture variable $0</a></h3>
<p>There is also a special capture variable <code>$0</code>. It contains the input captured by the currently executed parselet the sequence belongs to. A parselet is a function that consumes some sort of input, which will be discussed later.</p>
<p>Let's see how all capture variables, including <code>$0</code>, are growing when the items from the examples above are being executed.</p>
<table>
    <tr>
        <td>
            <strong>Capture</strong>
        </td>
        <td>
            $1
        </td>
        <td>
            $2
        </td>
        <td>
            $3
        </td>
        <td>
            $4
        </td>
        <td>
            $5
        </td>
    </tr>
    <tr>
        <td>
            <strong>Alias</strong>
        </td>
        <td>
            $predicate
        </td>
        <td></td>
        <td></td>
        <td></td>
        <td>
            $object
        </td>
    </tr>
    <tr>
        <td>
            <strong>Item</strong>
        </td>
        <td>
            <code>predicate => Word</code>
        </td>
        <td>
            <code>__</code>
        </td>
        <td>
            <code>'the'</code>
        </td>
        <td>
            <code>__</code>
        </td>
        <td>
            <code>object => Word</code>
        </td>
    </tr>
    <tr>
        <td>
            <strong>Input</strong>
        </td>
        <td>
            "Save"
        </td>
        <td>
            " "
        </td>
        <td>
            "the"
        </td>
        <td>
            " "
        </td>
        <td>
            "planet"
        </td>
    </tr>
    <tr>
        <td>
            <strong>$0 contains</strong>
        </td>
        <td>
            "Save"
        </td>
        <td>
            "Save "
        </td>
        <td>
            "Save the"
        </td>
        <td>
            "Save the "
        </td>
        <td>
            "Save the planet"
        </td>
    </tr>
</table>
<p>As you can see, <code>$0</code> always contains the input matched so far from the start of the parselet.</p>
<p><code>$0</code> can also be assigned to any other value, which makes it the result of the parselet in case no other result of higher precedence was set.</p>
<h2 id="sequence-interruption"><a class="header" href="#sequence-interruption">Sequence interruption</a></h2>
<p>todo</p>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>Sequences define occurences of items. An item inside of a sequence can have a meanigful alias.</p>
<p>Every item of a sequence that has been executed is called <em>a capture</em>, and can be accessed using context-variables, either by their offset (position of occurence) like <code>$1</code>, <code>$2</code>, <code>$3</code> or by their alias, like <code>$predicate</code>.</p>
<p>The special capture <code>$0</code> provides the consumed information read so far by the parselet, and can also be set to a value.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blocks-1"><a class="header" href="#blocks-1">Blocks</a></h1>
<p>Sequences are organized in blocks. Blocks may contain several sequences, which are executed in order of their definition. Every sequence inside of a block is separated by a newline.</p>
<p>The main scope of a Tokay program is also an implicit block, therefore it is not necessary to start every program with a new block.</p>
<h2 id="newlines"><a class="header" href="#newlines">Newlines</a></h2>
<p>Newlines (line-breaks, <code>\n</code> respectively) are meaningful, and belong to the syntax of blocks.<br>
They separate sequences inside a block from each other.</p>
<pre><code class="language-tokay">&quot;1st&quot; &quot;sequence&quot;
&quot;2nd&quot; &quot;sequence&quot;
&quot;3rd&quot; &quot;sequence&quot;
</code></pre>
<p>Instead of a newline, a semicolon (<code>;</code>) can also be used, which has the same meaning. A single-line sequence can be split into multiple lines by preceding a backslash (<code>\</code>) in front of the line-break.</p>
<pre><code class="language-tokay">&quot;1st&quot; \
    &quot;sequence&quot;
&quot;2nd&quot; &quot;sequence&quot; ; &quot;3rd&quot; &quot;sequence&quot;
</code></pre>
<p>The first and second example are literally the same.</p>
<h2 id="behavior"><a class="header" href="#behavior">Behavior</a></h2>
<p>Blocks have two important purposes:</p>
<p>First, they group sequences into items of other sequences.</p>
<pre><code class="language-tokay"># typical use of a block
if x &gt; 0 {
    x += 1
    print(&quot;x is now &quot; + x)
}
</code></pre>
<p>Second, they provide alternations for sequences which consume input. Therefore, their behavior different in Tokay in comparison to other programming languages. When all sequences inside of a block don't consume any input, the block behaves exactly as in other languages. But when a sequence consumes input, the block might stop execution of alternatives (=sequences) before the end of the block is reached.</p>
<pre><code class="language-tokay"># alternation behavior of a block, when used with tokens
'Hello' _ {
    checked = true  # always executed, consumes no input
    'World' print(&quot;Hello World&quot;)
    'Mars' print(&quot;Hello Mars&quot;)
    print(&quot;Hello Unknown&quot;)  # fallback case
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concepts"><a class="header" href="#concepts">Concepts</a></h1>
<p>In this chapter we deal in detail with the basic concepts of Tokay.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="terminology"><a class="header" href="#terminology">Terminology</a></h1>
<p>First of all, there are some terms which are oftenly used in Tokay.</p>
<h2 id="names-and-identifiers"><a class="header" href="#names-and-identifiers">Names and identifiers</a></h2>
<p>The naming rules for identifiers in Tokay differ to other programming languages, and this is an essential feature.</p>
<ol>
<li>Any identifier may not start with any digit (<code>Char&lt;0-9&gt;</code>).</li>
<li>Variable names have to start with any lower-case letter (<code>Char&lt;a-z&gt;</code>)</li>
<li>Constant names have to start either
<ul>
<li>when they refer consumable values, with an upper-case letter or an underscore<br>(<code>Char&lt;A-Z_&gt;</code>)</li>
<li>otherwise they can also start with a lower-case letter, likewise variable names<br>(<code>Char&lt;a-z&gt;</code>).</li>
</ul>
</li>
</ol>
<p>Some examples for better understanding:</p>
<pre><code class="language-tokay"># Valid
pi : 3.1415
mul2 : @x { x * 2 }
Planet : @{ 'Venus' ; 'Earth'; 'Mars' }
the_Tribe = &quot;Cherokee&quot;

# Invalid
Pi : 3.1415  # float value is not consumable
planet : @{ 'Venus' ; 'Earth'; 'Mars' }  # identifier must specify consumable
The_Tribe = &quot;Cherokee&quot;  # Upper-case variable name not allowed

9th = 9  # valid, but is interpreted as sequence `9 th = 9`
</code></pre>
<p>More about <em>consumable</em> and <em>non-consumable</em> values, <em>variables</em> and <em>constants</em> is discussed shortly.</p>
<h2 id="variables-and-constants"><a class="header" href="#variables-and-constants">Variables and constants</a></h2>
<p>Symbolic identifiers for named values can either be defined as <em>variables</em> or <em>constants</em>.</p>
<pre><code class="language-tokay">variable = 0  # assign 0 to a variable
constant : 0  # assign 0 to a constant
</code></pre>
<p>Obviously, this looks like the same. <code>variable</code> becomes 0 and <code>constant</code> also. Let's try to modify these values afterwards.</p>
<pre><code class="language-tokay">variable += 1  # increment variable by 1
constant += 1  # throws compiler error: Cannot assign to constant 'constant'
</code></pre>
<p>Now <code>variable</code> becomes 1, but <code>constant</code> can't be assigned and Tokay throws a compile error.
What you can do is to redefine the constant with a new value.</p>
<pre><code class="language-tokay">variable++    # increment variable by 1
constant : 1  # re-assign constant to 1
</code></pre>
<p>The reason is, that <em>variables</em> are evaluated at runtime, whereas <em>constants</em> are evaluated at compile-time, before the program is being executed.</p>
<p>The distinction between variables and constants is a tradeoff between flexibility and predictivity to make different concepts behind Tokay possible. The values of variables aren't known at compile-time, therefore predictive construction of code depending on the values used is not possible. On the other hand, constants can be used before their definition, which is very useful when thinking of functions being called by other functions before their definition.</p>
<h2 id="callables-and-consumables"><a class="header" href="#callables-and-consumables">Callables and consumables</a></h2>
<p>Some values are callable. Generally, all tokens, functions and builtins are <em>callable</em>.</p>
<p>Here are some usages of callables:</p>
<pre><code class="language-tokay">int(&quot;123&quot;)        # Builtin int constructor
Int               # Builtin Int parser token
Char&lt;A-Z&gt;         # builtin char token
'Check'           # Touch token 'Check'
''Bold''          # Match token 'Bold'

s = &quot;Hello&quot;
s.upper           # calls method 'str_upper', returns &quot;HELLO&quot;
s[0]              # Internally call 'str_get_item', returns &quot;H&quot;

f : @x { x * 2 }  # function definition
f(42)             # function call, producing 84
</code></pre>
<p>Additionally, a callable can be attributed to be <em>consumable</em>. This is the case when the callable either makes use of another consumable callable, or it direcly consumes input. Consumables are always identified by either starting with an upper-case letter or an underscore. A function which makes use of a consumable is called <em>parselet</em>.</p>
<pre><code class="language-tokay"># invalid attempt; the parselet makes use of consumables,
# but is assigned to a name for a non-consumable constant.
assign : @{
    Ident _ expect '=' _ expect Expr
}

# creating a parselet
Assign : @{
    Ident _ expect '=' _ expect Expr
}
</code></pre>
<h2 id="scopes"><a class="header" href="#scopes">Scopes</a></h2>
<p>Variables and constants are organized in scopes.</p>
<ol>
<li>A scope is any block, and the global scope.</li>
<li>Constants can be defined in any block. They can be re-defined by other constants in the same or in subsequent blocks. Constants being re-defined in a subsequent block are valid until the block ends, afterwards the previous constant will be valid again.</li>
<li>Variables are only distinguished between global and local scope of a parselet. Unknown variables used in a parselet block are considered as local variables.</li>
</ol>
<p>Here's some commented code for clarification:</p>
<pre><code class="language-tokay">x = 10  # global scope variable x
y : 2000  # global scope constant y
z = 30  # global scope variable z

# entering new scope of function f
f : @x {  # x is overridden as local variable
    y : 1000  # local constant y overrides global constant y temporarily in this block
    z += y + x # adds local constant y and local value of x to global value of z
}

f(42)

# back in global scope, x is still 10, y is 2000 again, z is 1072 now.
x y z
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="values"><a class="header" href="#values">Values</a></h1>
<p>Generally, everything in Tokay is some kind of value or part of a value. The term &quot;value&quot; refers to both simple atomic values like booleans, numbers, strings but also objects which are partly mutable, recursive or callable.</p>
<h2 id="atomics"><a class="header" href="#atomics">Atomics</a></h2>
<p><em>Atomic</em> values stand on their own and are generally not mutable in the sense of an object. These values are the following:</p>
<pre><code class="language-tokay">void           # values to representing just nothing
null           # values representing a defined &quot;set to null&quot;
true false     # boolean values
</code></pre>
<p>Using the builtin function <code>bool(v)</code>, a boolean value can be constructed from any other value <code>v</code>, by testing for truth.</p>
<h2 id="numbers"><a class="header" href="#numbers">Numbers</a></h2>
<p>Tokay supports <code>int</code> and <code>float</code> as numeric types.</p>
<pre><code class="language-tokay">42 -23         # signed integer number object of arbitrary size (bigint)
3.1415 -1.337  # signed 64-bit float number object
</code></pre>
<p>For numbers, the following methods can be used:</p>
<ul>
<li><code>int(v)</code> - contructs an int value from any other value <code>v</code></li>
<li><code>float(v)</code> - contructs a float value from any other value <code>v</code></li>
<li><code>float.ceil()</code> - returns the next integer ceiling of a float</li>
<li><code>float.fract()</code> - returns only the fractional part of a float</li>
<li><code>float.trunc()</code> - truncates the fractional part off a float</li>
</ul>
<h2 id="strings"><a class="header" href="#strings">Strings</a></h2>
<p>A string (<code>str</code>) is a unicode-character sequence of arbitrary length.</p>
<pre><code class="language-tokay">s = &quot;Tokay ðŸ¦Ž&quot;
s = s + &quot; is cool&quot;
s += &quot;!&quot;
</code></pre>
<p><code>str</code> objects can be concatenated by the operators <code>+</code> and <code>+=</code>.<br>
They can also be multiplied by the operators <code>*</code> and <code>*=</code>.</p>
<p>Additionally, they provide the following methods:</p>
<ul>
<li><code>str(v)</code> - constructs a string object from any other value <code>v</code></li>
<li><code>str.byteslen()</code> - return total length of bytes used by the string</li>
<li><code>str.endswith(s)</code> - check if string ends with postfix <code>s</code></li>
<li><code>str.join(l)</code> - create a string delimited by str from a list <code>l</code></li>
<li><code>str.len()</code> - return number of characters in the string</li>
<li><code>str.lower()</code> - turns any upper-case characters of a string into lower-case order</li>
<li><code>str.replace(from, to=&quot;&quot;, n=void)</code> - replace string <code>from</code> by <code>to</code> for at least <code>n</code>-times</li>
<li><code>str.startswith(s)</code> - check if string begins with prefix <code>s</code></li>
<li><code>str.substr(start=0, length=void)</code> - returns a substring from <code>start</code> of <code>length</code> or to the end</li>
<li><code>str.upper()</code> - turns any lower-case characters of a string into lower-case order</li>
</ul>
<h2 id="lists"><a class="header" href="#lists">Lists</a></h2>
<p>A list is a sequence of arbitrary values in a row. Therefore, a list can also contain further lists, or other complex objects. A list is also mutable, which means items can be extended or removed during runtime.</p>
<pre><code class="language-tokay"># list of values
(42, true, &quot;yes&quot;)
l = (42 true &quot;yes&quot;)
l[1] = false
l.push(&quot;ðŸ¦Ž&quot;)
l.len()  # 4
</code></pre>
<p>Lists can be concatenated by the <code>+</code>- and <code>+=</code>-operators, and provide the following methods:</p>
<ul>
<li><code>list(*args)</code> - constructs a new list from all arguments provided</li>
<li><code>list.flatten()</code> - integrates items of lists inside a list into itself</li>
<li><code>list.len()</code> - returns number of items in the list</li>
<li><code>list.push(item, index=void)</code> - either appends an <code>item</code> to the list or inserts it at position <code>index</code></li>
<li><code>list.pop(index=void)</code> - either pops the last item off the list or removes and returns item at position <code>index</code></li>
</ul>
<h2 id="dicts"><a class="header" href="#dicts">Dicts</a></h2>
<p>Dictionaries (&quot;dicts&quot;) are hash tables or maps with key-value-pairs, where a value is referenced by using the key as its storage location.</p>
<pre><code class="language-tokay"># dictionary (dict), a map of key-value-pairs
(i =&gt; 42, b =&gt; true, status =&gt; &quot;success&quot;, true =&gt; false)
d = (i =&gt; 42 b =&gt; true status =&gt; &quot;success&quot; true =&gt; false)
d[&quot;angle&quot;] = 23.5  # add key &quot;angle&quot;
d[&quot;i&quot;] = void  # remove key &quot;i&quot;
</code></pre>
<p>Dicts provide the following methods:</p>
<ul>
<li><code>dict()</code> - creates a new, empty dict</li>
<li><code>dict_clone()</code> - create an independ copy of dict</li>
<li><code>dict_items()</code> - returns a list of lists (key, value)</li>
<li><code>dict_keys()</code> - returns a list of keys</li>
<li><code>dict.len()</code> - returns number of items in the dict</li>
<li><code>dict.merge(other)</code> - merges antoher dict into the dict</li>
<li><code>dict_pop(k=void, d=void)</code> - remove and return k from dict; returns d when key is not present; when k is not present, the last item will be removed.</li>
<li><code>dict_push(k, v)</code> - insert v as key k into dict</li>
<li><code>dict_values()</code> - returns a list of values</li>
</ul>
<h2 id="tokens"><a class="header" href="#tokens">Tokens</a></h2>
<p>Tokens are callables consuming input from the stream. They are object values as well. They always return a value parsed from the input stream in case the token matches. Otherwise, tokens usually reject the current block branch or parselet, to try other alternatives.</p>
<pre><code class="language-tokay">'touch'        # silently touch a string in the input (low severity)
''match''      # verbosely match a string from the input (high severity)
Char&lt;A-Z0-9&gt;+  # matching a sequence of multiple valid characters
Int            # built-in token for parsing and returning Integer values
Word(3)        # built-in token Word, matching at least words of length 3
</code></pre>
<blockquote>
<p>In terms of parsing, tokens are the terminal symbols of a context-free grammar.</p>
</blockquote>
<h2 id="functions-and-parselets"><a class="header" href="#functions-and-parselets">Functions and parselets</a></h2>
<p>Functions are sub-programs for a specific task or routine which can be used for multiple tasks. A function can accept arguments with default values.</p>
<pre><code class="language-tokay"># function that doubles its value
f : @x { x * 2 }
f(9)  # 18

# anonymous function example
@x { x * 3 }(5)  # 15, returned by anonymous function that is called in-place
</code></pre>
<p>Parselets are more-specific functions consuming input and used for parsing. They are conceptionally the same, but also they are very distinguishable in their usage.</p>
<pre><code># parselet that parses simple assignments to variables
Assign : @{
    variable =&gt; Ident _ '=' _ value =&gt; Number
}

# called on a given input `n = 42`...
Assign
# ... returns dict `(variable =&gt; &quot;n&quot;, value =&gt; 42)`
</code></pre>
<blockquote>
<p>In terms of parsing, parselets are considered as non-terminal symbols of a context-free grammar.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokens-1"><a class="header" href="#tokens-1">Tokens</a></h1>
<p>Tokens are the fundamental building blocks used to process input. Tokay implements first-level tokens which direcly consume input, but usages of parselets, which are functions consuming input, are considered as second-level tokens, and are at least tokens as well.</p>
<h2 id="touch-and-match"><a class="header" href="#touch-and-match"><code>'touch'</code> and <code>''match''</code></a></h2>
<p>To match exact strings of characters from the input, like keywords, the <em>match</em> and <em>touch</em> token-type is used. Touch was yet mostly used in our examples, but match is also useful, depending on use-case.</p>
<pre><code class="language-tokay">'Touch'    # match string in the input and discard
''Match''  # match string in the input and take
</code></pre>
<p>The only difference between the two types is, that a match has a higher severity than a touch, and will be recognized within automatic value construction.
Both type of matches can be referred by capture variables, therefore</p>
<pre><code class="language-tokay">'Match' $1
</code></pre>
<p>is the same result like a direct match.</p>
<p>Check out the following one-liner when executed on the input <code>1+2-3+4</code>, it will return <code>(1, &quot;+&quot;, (2, (3, &quot;+&quot;, 4)))</code>. The matches on the plus (<code>''+''</code>) is taken into the result, the touch on minus (<code>'-'</code>) are discarded.</p>
<pre><code class="language-tokay">E : { E ''+'' E ; E '-' E; Integer }; E
</code></pre>
<h2 id="char"><a class="header" href="#char"><code>Char</code></a></h2>
<p>To match a character, the <code>Char</code>-token is both builtin and part of Tokay's syntax.</p>
<ul>
<li>Single characters are either specified by a Unicode-character or an escape sequence</li>
<li>Ranges are delimited by a dash (<code>-</code>). If a Max-Min-Range is specified, it is automatically converted into a Min-Max-Range, so <code>Char&lt;z-a&gt;</code> is equal to <code>Char&lt;a-z&gt;</code>.</li>
<li>If a dash (<code>-</code>) should be part of the character-class, it should be specified first or last.</li>
<li>If a circumflex (<code>^</code>) is specified as first character in the character-class, the character-class will be inverted, so <code>Char&lt;^a-z&gt;</code> matches everything except <code>a</code> to <code>z</code>.</li>
</ul>
<pre><code class="language-tokay">Char              # any character
Char&lt;a&gt;           # just &quot;a&quot;
Char&lt;az&gt;          # either &quot;a&quot; or &quot;z&quot;
Char&lt;a-z&gt;         # any character from &quot;a&quot; to &quot;z&quot;
Char&lt;a-zA-Z0-9_&gt;  # All ASCII digit or letter and underscore
Char&lt;^0-9&gt;        # Any character except ASCII digits
Char&lt;-+*/&gt;        # Mathematical base operators (minus-dash first!)
</code></pre>
<blockquote>
<p>When using the <code>Char</code>-token with the multiplicative operators <code>+</code> (many repetition) or <code>*</code> (kleene, none or many), they are internally revised to a <code>Chars</code>-version, for better performance.</p>
</blockquote>
<h2 id="builtin-tokens"><a class="header" href="#builtin-tokens">Builtin tokens</a></h2>
<p>The following tokens are builtin and can be parametrized.</p>
<ul>
<li><code>Ident</code> - parses any C-style idenfifier name</li>
<li><code>Int(base=10, with_signs=true)</code> - parses an int-value to the provided base, optionally with <code>+</code> or <code>-</code> signs</li>
<li><code>Float(with_signs=true)</code> - parses a float-value, optionally with <code>+</code> or <code>-</code> signs</li>
<li><code>Number</code> - parses <code>Float</code> or <code>Int</code></li>
<li><code>Token</code> - either parses <code>Number</code>, <code>Word</code> or <code>AsciiPunctuation</code></li>
<li><code>Word(min=1, max=void)</code> - parses any word, number, etc. with the specified <code>min</code>- and <code>max</code>-length</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="parselets"><a class="header" href="#parselets">Parselets</a></h1>
<blockquote>
<p>Currently this chapter is an unfinished work-in-progress.</p>
</blockquote>
<p>Parselets are functions, which consume input.</p>
<h2 id="begin-end"><a class="header" href="#begin-end">begin, end</a></h2>
<p><em>coming soon</em></p>
<h2 id="accept-reject"><a class="header" href="#accept-reject">accept, reject</a></h2>
<p><em>coming soon</em></p>
<h2 id="repeat"><a class="header" href="#repeat">repeat</a></h2>
<p><em>coming soon</em></p>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<p>A function is introduced by an at-character (<code>@</code>), where a parameter list might optionally follow. The function's body is obgligatory, but can also exist of just a sequence or an item. Functions are normally assigned to constants, but can also be assigned to variables, with some loose of flexibility, but opening other features.</p>
<pre><code class="language-tokay"># f is a function
f : @x = 1 {
    print(&quot;I am a function, x is &quot; + x)
}

f        # calls f, because it has no required parameters!
f()      # same as just f
f(5)     # calls f with x=5
f(x=10)  # calls f with x=10
</code></pre>
<p>Tokay functions that consume input are called <em>parselets</em>. It depends on the function's body if its either considered to be a function or a parselet. Generally, when talking about parselets in Tokay, both function and real parselets are meant as shorthand.</p>
<pre><code class="language-tokay"># P is a parselet, as it uses a consuming token
P : @x = 1 {
    Word print(&quot;I am a parselet, x is &quot; + x)
}

P        # calls P, because it has no required parameters!
P()      # same as just P
P(5)     # calls P with x=5
P(x=10)  # calls P with x=10
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-structures"><a class="header" href="#control-structures">Control structures</a></h1>
<p>In comparison to many other languages, control structures in Tokay are part of expressions. They always return a value, which defaults to <code>void</code> when no other value is explicitly returned.</p>
<h2 id="ifelse"><a class="header" href="#ifelse">if...else</a></h2>
<p>The <code>if...else</code>-construct implements conditional branching depending on the result of an expression.<br>
The <code>else</code> part is optional, and can be omitted.</p>
<pre><code class="language-tokay">if sense == 42 &amp;&amp; axis == 23.5 {
    print(&quot;Well, this is fine!&quot;)
}
else {
    print(&quot;That's quite bad.&quot;)
}
</code></pre>
<p>As stated before, all control structures are part of Tokays expression syntax. Above example can easily by turned into</p>
<pre><code class="language-tokay">print(
    if sense == 42 &amp;&amp; axis == 23.5
        &quot;Well, this is fine!&quot;
    else
        &quot;That's quite bad.&quot;
)
</code></pre>
<p>or directly used inside of an expression.</p>
<pre><code class="language-tokay"># if can be part of an expression
Word &quot;Hello &quot; + if $1 == &quot;World&quot; &quot;Earth&quot; else $1
</code></pre>
<p><code>if...else</code> constructs working on static expressions are optimized away during compile-time.</p>
<h2 id="loop"><a class="header" href="#loop">loop</a></h2>
<p>The <code>loop</code>-keyword is used to create loops, either with an aborting conditions on top or without any condition.</p>
<pre><code class="language-tokay"># Countdown
count = 10
loop count &gt;= 0 print(
    if --count == 3
        &quot;Ignition&quot;
    else if count &lt; 0
        &quot;Liftoff&quot;
    else
        count
)
</code></pre>
<p>A loop can be aborted everytime using the <code>break</code>-statement.<br>
The <code>continue</code>-statement restarts the loop at the beginning, but a present abort-condition will be re-checked again.</p>
<pre><code class="language-tokay">count = 10
loop {
    count = count - 1
    if count == 3 {
        print(&quot;Ignition&quot;)
        continue
    }

    print(count)
    if count == 0 {
        print(&quot;Liftoff&quot;)
        break
    }
}
</code></pre>
<p>A loop without any aborting condition loops forever.</p>
<pre><code class="language-tokay">loop print(&quot;Forever!&quot;)
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p>The <code>for</code>-keyword introduces a special form of loop that syntacically glues the parts <em>initialization</em>, <em>abort condition</em> and <em>iteration</em> together into a separate syntactic element.</p>
<pre><code class="language-tokay">for count = 10; count &gt;= 0; count-- {
    print(i)
}
</code></pre>
<blockquote>
<p>This syntax is abandoned. The upcoming version 0.7 of Tokay will only support <code>for...in</code>.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-a-keywords"><a class="header" href="#appendix-a-keywords">Appendix A: Keywords</a></h1>
<p>In Tokay, the following keywords are reserved words for control structures, values and special operators.</p>
<ul>
<li><code>accept</code> - accept parselet, optionally with a return value</li>
<li><code>begin</code> - sequence to execute at begining of a parselet</li>
<li><code>break</code> - break from a loop, optonally with a return value</li>
<li><code>continue</code> - restart iteration in a loop</li>
<li><code>else</code> - fallback for <code>if</code> constructs</li>
<li><code>end</code> - sequence to execute at end of a parselet</li>
<li><code>exit</code> - stop program execution, optional with exit code</li>
<li><code>expect</code> - operator for consumable that expects the consumable and throws an error if not present</li>
<li><code>false</code> - the <em>false</em> value</li>
<li><code>for</code> - head-controlled <code>for</code> loop</li>
<li><code>if</code> - branch based on the result of a conditional expression</li>
<li><code>in</code> - part of the <code>for</code>-loop syntax</li>
<li><code>loop</code> - head-controlled loop with an optional abort conition</li>
<li><code>next</code> - continue with next sequence in a block</li>
<li><code>not</code> - operator for consumable that satisfies when the consumable is not consumed</li>
<li><code>null</code> - the <em>null</em> value</li>
<li><code>peek</code> - operator for consumable that satisfies when consumable is consumed but the reader rolls back afterwards</li>
<li><code>push</code> - accept a sequence by pushing a value</li>
<li><code>reject</code> - reject parselet as not being consumed</li>
<li><code>repeat</code> - repeat parselet, optionally push a result</li>
<li><code>return</code> - same like <code>accept</code>, but with a meaning for ordinary functions</li>
<li><code>true</code> - the <em>true</em> value</li>
<li><code>void</code> - the <em>void</em> value</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-b-operators"><a class="header" href="#appendix-b-operators">Appendix B: Operators</a></h1>
<p>Tokay implements the following operators for use in expressions. The operators are ordered by precedence, operators in the same row share the same precedence.</p>
<p>Don't confuse with some rows which look as redundant, this depends on either the operator is delimited by whitespace from its operands or not.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Operator
            </th>
            <th>
                Description
            </th>
            <th>
                Associativity
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>=<br>+=<br>-=<br>*=<br>/=<br>//=<br>%=</td>
            <td>Assignment, combined operation-assignment</td>
            <td>left</td>
        </tr>
        <tr>
            <td>||</td>
            <td>Logical or</td>
            <td>left</td>
        </tr>
        <tr>
            <td>&&</td>
            <td>Logical and</td>
            <td>left</td>
        </tr>
        <tr>
            <td>==<br>!=<br><<br><=<br>>=<br>></td>
            <td>Equal, unequal, comparison</td>
            <td>left</td>
        </tr>
        <tr>
            <td>+<br>-</td>
            <td>Add, subtract</td>
            <td>left</td>
        </tr>
        <tr>
            <td>*<br>/<br>//<br>%</td>
            <td>Multiply, divide, integer divide, modulo</td>
            <td>left</td>
        </tr>
        <tr>
            <td>-<br>!</td>
            <td>Negate, not</td>
            <td>right</td>
        </tr>
        <tr>
            <td>++<br>--</td>
            <td>Increment, decrement</td>
            <td>right</td>
        </tr>
        <tr>
            <td>(...)</td>
            <td>Inline sequence</td>
            <td>left</td>
        </tr>
        <tr>
            <td>(...)<br>[...]<br>.</td>
            <td>Call parameters, subscript, attribute</td>
            <td>left</td>
        </tr>
    </tbody>
</table>
<p>Operators produce different results depending on the data-types of their operands. For example, <code>3 * 10</code> multiplies 10 by 3, whereas <code>3 * &quot;test&quot;</code> creates a new string repeating &quot;test&quot; 3 times. Try out the results of different operands in a Tokay REPL for clarification.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-c-modifiers"><a class="header" href="#appendix-c-modifiers">Appendix C: Modifiers</a></h1>
<p>Tokay allows to use the following modifiers for calls to consumable values. Modifiers are used to describe repetitions or optional occurences of consumables.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Modifier
            </th>
            <th>
                Description
            </th>
            <th>
                Examples
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>+</td>
            <td>Positive repetition (one or many)</td>
            <td>`'t'+, P(n=3)+`</td>
        </tr>
        <tr>
            <td>?</td>
            <td>Optional (one or none)</td>
            <td>`'t'?, P(n=3)?`</td>
        </tr>
        <tr>
            <td>*</td>
            <td>Kleene star (none or many)</td>
            <td>`'t'*, P(n=3)*`</td>
        </tr>
    </tbody>
</table>
<h2 id="redudancy-with-expressional-operators"><a class="header" href="#redudancy-with-expressional-operators">Redudancy with expressional operators</a></h2>
<p>You might have noticed that the operators <code>+</code> and <code>*</code> are used as operators for add and multiply as well. To clarify meaning, all modifiers stick to the token they belong to, and no whitespace is accepted between them. Modifiers are only allowed on tokens and parselet calls, and nowhere else, as it makes no sense.</p>
<p>Here are some examples for clarification:</p>
<pre><code class="language-tokay">'t' * 3    # match 't' and repeat the result 3 times
't'* * 3   # match 't' one or multiple times and repeat the result 3 times
't' * * 3  # syntax error
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-d-builtins"><a class="header" href="#appendix-d-builtins">Appendix D: Builtins</a></h1>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h2 id="tokens-2"><a class="header" href="#tokens-2">Tokens</a></h2>
<p>The following tokens are built into Tokay and can be used immediatelly. Programs can override these constants on-demand.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Token
            </th>
            <th>
                Token+
            </th>
            <th>
                Description
            </th>
        </tr>
    </thead>
    <tbody>
        <tr><td>Alphabetic</td><td>Alphabetics</td><td>All Unicode characters having the Alphabetic property</td></tr>
        <tr><td>Alphanumeric</td><td>Alphanumerics</td><td>The union of Alphabetic and Numeric</td></tr>
        <tr><td>Ascii</td><td>Asciis</td><td>All characters within the ASCII range.</td></tr>
        <tr><td>AsciiAlphabetic</td><td>AsciiAlphabetics</td><td>All ASCII alphabetic characters <code>[A-Za-z]</code></td></tr>
        <tr><td>AsciiAlphanumeric</td><td>AsciiAlphanumerics</td><td>ASCII alphanumeric characters <code>[0-9A-Za-z]</code></td></tr>
        <tr><td>AsciiControl</td><td>AsciiControls</td><td>All ASCII control characters <code>[\x00-\x1F\x7f]</code>. SPACE is not a control character.</td></tr>
        <tr><td>AsciiDigit</td><td>AsciiDigits</td><td>ASCII decimal digits <code>[0-9]</code></td></tr>
        <tr><td>AsciiGraphic</td><td>AsciiGraphics</td><td>ASCII graphic character <code>[!-~]</code></td></tr>
        <tr><td>AsciiHexdigit</td><td>AsciiHexdigits</td><td>ASCII hex digits <code>[0-9A-Fa-f]</code></td></tr>
        <tr><td>AsciiLowercase</td><td>AsciiLowercases</td><td>All ASCII lowercase characters <code>[a-z]</code></td></tr>
        <tr><td>AsciiPunctuation</td><td>AsciiPunctuations</td><td>All ASCII punctuation characters <code>[-!"#$%&'()*+,./:;<=>?@[\\\]^_`{|}~]</code></td></tr>
        <tr><td>AsciiUppercase</td><td>AsciiUppercases</td><td>All ASCII uppercase characters <code>[A-Z]</code></td></tr>
        <tr><td>AsciiWhitespace</td><td>AsciiWhitespaces</td><td>All characters defining ASCII whitespace <code>[ \t\n\f\r]</code></td></tr>
        <tr><td>Char</td><td>Chars</td><td>Any character, except EOF</td></tr>
        <tr><td>Char<...></td><td>Chars<...></td><td>Any character of specified character-class, except EOF</td></tr>
        <tr><td>Control</td><td>Controls</td><td>All Unicode characters in the controls category</td></tr>
        <tr><td>Digit</td><td>Digits</td><td>ASCII decimal digits <code>[0-9]</code></td></tr>
        <tr><td>EOF</td><td>-</td><td>Matches End-Of-File.</td></tr>
        <tr><td>Lowercase</td><td>Lowercases</td><td>All Unicode characters having the Lowercase property</td></tr>
        <tr><td>Numeric</td><td>Numerics</td><td>All Unicode characters in the numbers category</td></tr>
        <tr><td>Uppercase</td><td>Uppercases</td><td>All Unicode characters having the Uppercase property</td></tr>
        <tr><td>Whitespace</td><td>Whitespaces</td><td>All Unicode characters having the White_Space property</td></tr>
        <tr><td>Void</td><td>-</td><td>The empty token, which consuming nothing. But it consumes!</td></tr>
    </tbody>
</table>
<p>The respective properties of the built-in character classes is described in Chapter 4 (Character Properties) of the <a href="https://www.unicode.org/versions/latest/">Unicode Standard</a> and specified in the <a href="https://www.unicode.org/reports/tr44">Unicode Character Database</a> in <a href="https://www.unicode.org/Public/UCD/latest/ucd/DerivedCoreProperties.txt">DerivedCoreProperties.txt</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix-e-escape-sequences"><a class="header" href="#appendix-e-escape-sequences">Appendix E: Escape sequences</a></h1>
<p>Escape sequences can be used inside of strings, match/touch tokens and character-classes to encode any unicode character. They are introduced with a backslash.</p>
<p>Escape-sequences should be used to simplify the source code and its readability, but any unicode character can also be directly expressed.</p>
<table>
    <thead>
        <tr class="title">
            <th>
                Sequence
            </th>
            <th>
                Description
            </th>
            <th>
                Examples
            </th>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>\a \b \f \n \r \t \v</td>
            <td>Bell (alert), backspace, formfeed, new line, carriage return, horizontal tab, vertical tab, </td>
            <td>"\a\b\f\n\r\t\v"</td>
        </tr>
        <tr>
            <td>\' \" \\</td>
            <td>Quotation marks, backslash</td>
            <td>"\'\"\\"  # '"\</td>
        </tr>
        <tr>
            <td>\ooo</td>
            <td>ASCII character in octal notation</td>
            <td>"\100"  # @</td>
        </tr>
        <tr>
            <td>\xhh</td>
            <td>ASCII character in hexadecimal notation</td>
            <td>"\xCA"  # ÃŠ</td>
        </tr>
        <tr>
            <td>\uhhhh</td>
            <td>16-Bit Unicode character in hexadecimal notation</td>
            <td>"\u20ac"  # â‚¬</td>
        </tr>
        <tr>
            <td>\Uhhhhhhhh</td>
            <td>32-Bit Unicode character in hexadecimal notation</td>
            <td>"\U0001F98E"  # ðŸ¦Ž</td>
        </tr>
    </tbody>
</table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
